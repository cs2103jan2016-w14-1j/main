# A0112204E
###### \shared\LogHandler.java
``` java
package shared;

import java.util.logging.Logger;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.io.IOException;

public class LogHandler {
	
	private static final String LOG_FILE = "CataList.log";
	private static final String LOG_NAME = "CataListLog";
	private static FileHandler fileHandler;
	private static Logger logger;

	/**
	 * Get instance of Logger
	 * @return Logger log file
	 */
	public static Logger retrieveLog() {
		if(logger == null) {
			try {
				logger = Logger.getLogger(LOG_NAME);
				logger.setLevel(Level.INFO);
				logger.addHandler(getFileHandler());
			} catch (SecurityException | IOException e) {
			}
		}
		return logger;
	}
	
	private static FileHandler getFileHandler() throws SecurityException, IOException {
		if(fileHandler == null) {
			fileHandler = new FileHandler(LOG_FILE);
		}
		return fileHandler;
	}
}
```
###### \ui\Application\MainGUI.java
``` java
package ui.Application;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;

public class MainGUI extends Application {
	
	/**
	 * This is the main class that launches the application
	 * It maintains the stage/window of the application and closes the window when
	 * a particular key event is detected
	 * It does nothing else other than launching the application
	 * 
	 */
    
    private static final String APP_NAME = "CataList";
    private static final String GUI_PATH = "/ui/View/MainGUI.fxml";
    private static final String STYLESHEET_PATH = "/ui/Application/Stylesheets/MainGUI.css";
    private static final String ICON_PATH = "/ui/Application/Stylesheets/Background/catalist_icon.png";
    
    @Override
    public void start(Stage stage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource(GUI_PATH));
        
        stage.getIcons().add(new Image(ICON_PATH));
        stage.setTitle(APP_NAME);   
      
        Scene scene = new Scene(root);
        scene.getStylesheets().add(getClass().getResource(STYLESHEET_PATH).toExternalForm());
        stage.setScene(scene);
        stage.requestFocus();
        stage.show();
        
        quitProgram(scene, stage);
    }
    
    private void quitProgram(Scene scene, Stage stage) {	
        scene.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent evt) -> {
            if (evt.getCode().equals(KeyCode.ESCAPE)) {
            	stage.close();
            	Platform.exit();
            }
        });
    }

    public static void main(String[] args) {
        launch(args);
    }  
}
```
###### \ui\Application\Stylesheets\HelpPage.css
``` css
@font-face {
    font-family: delicious-bold;
    src: url("Fonts/Delicious-Bold.otf");
}

@font-face {
    font-family: delicious-smallcaps;
    src: url("Fonts/Delicious-SmallCaps.otf");
}

#helpListContainer {
	-fx-background-color: rgb(255, 255, 255, 0.8);
	-fx-background-radius: 20 20 20 20;
	-fx-padding: 20;
}

#helpHeading {
	-fx-font-size: 30px;
    -fx-font-family: delicious-smallcaps;
    -fx-text-fill: black;
}

.table-view {
    -fx-base: beige;
    -fx-control-inner-background: transparent;
    -fx-background-color: transparent;
    -fx-table-cell-border-color: transparent;
    -fx-table-header-border-color: transparent;
    -fx-background-radius: 20 20 20 20;
}

.table-view .column-header-background {
    -fx-background-color: transparent;
}

.table-view .column-header, .table-view .filler {
    -fx-size: 35;
    -fx-border-width: 0 0 1 0;
    -fx-background-color: transparent;
    -fx-border-color: 
        transparent
        transparent
        derive(black, 80%) 
        transparent;
    -fx-border-insets: 0 10 1 0;
    -fx-opacity: 0;
}

.table-view .column-header .label {
    -fx-font-size: 10px;
    -fx-font-family: delicious-smallcaps;
    -fx-text-fill: black;
    -fx-alignment: center-left;
    -fx-opacity: 0;
}

.table-view:focused .table-row-cell:filled:focused:selected {
    -fx-background-color: -fx-focus-color;
}

.table-cell {
	-fx-font-size: 15px;
}

.split-pane:horizontal > .split-pane-divider {
    -fx-border-color: transparent #1d1d1d transparent #1d1d1d;
    -fx-background-color: transparent, derive(#1d1d1d,20%);
}

.split-pane {
    -fx-padding: 1 0 0 0;
}

#commandColumn {
	-fx-alignment: TOP_RIGHT; 
	-fx-text-fill: black;
}

#formatColumn {
	-fx-text-fill: orangered;
}
```
###### \ui\Application\Stylesheets\MainGUI.css
``` css
@font-face {
    font-family: delicious-bold;
    src: url("Fonts/Delicious-Bold.otf");
}

@font-face {
    font-family: delicious-roman;
    src: url("Fonts/Delicious-Roman.otf");
}

@font-face {
	font-family: comicNeue-angular-regular;
	src: url("Fonts/ComicNeue-Angular-Regular.otf");
}

@font-face {
	font-family: docker-one;
	src: url("Fonts/Docker-One.ttf");
}

@font-face {
	font-family: aileron-bold;
	src: url("Fonts/Aileron-Bold.otf");
}

@font-face {
	font-family: aileron-thin-italic;
	src: url("Fonts/Aileron-ThinItalic.otf");
}

@font-face {
	font-family: aileron-semi-bold;
	src: url("Fonts/Aileron-SemiBold.otf");
}

.root {
	-fx-background-size: cover;
}

#backgroundPane {
	-fx-background-color: linear-gradient(orangered, orange);
}

#mainPane {
	-fx-alignment: center ; 
	-fx-padding: 50 0 0 0;
}

#titleMessage {
	-fx-font-family: "DOCKER";
	-fx-font-size: 40px;
	-fx-fill: white;
	-fx-stroke: darkorange;
	-fx-stroke-width: 2px;
}

#subMessage {
	-fx-font-family: delicious-roman;
	-fx-font-size: 15px;
	-fx-fill: white;
}

#calendarContainer {
	-fx-background-color: rgb(255, 255, 255, 0.8);
	-fx-background-radius: 20 20 20 20;
	-fx-max-width: 800;
	-fx-max-height: 800;
	-fx-alignment: center;
	-fx-padding: 20;
}

#calendarTime {
	-fx-text-fill: maroon;
	-fx-font-size: 25px;
}

.date-picker-popup {
	-fx-font-size: 15px;
	-fx-background-color: rgb(0, 0, 0, 0);
	-fx-max-width: 500;
	-fx-pref-height: 500;
}

.date-picker-popup > .month-year-pane {
	-fx-font-size: 15px;
	-fx-background-color: rgb(0, 0, 0, 0);
}

.date-picker-popup > * {
	-fx-background-color: rgb(0, 0, 0, 0);
}

.date-picker-popup > * > .day-cell {
	-fx-font-size: 15px;
	-fx-background-color: rgb(0, 0, 0, 0);
	-fx-border-color: transparent;
        
}

.date-picker-popup > * > .today {
	-fx-background-color: orangered;
}


.tab-pane .tab-header-area .tab-header-background {
    -fx-opacity: 0;
}

.tab-pane .tab-header-area {
	-fx-padding: 0 0 0 10;
}

.tab-pane .tab {
    -fx-background-color: rgb(255, 255, 255, 1);
    -fx-opacity: 0.5;
    -fx-pref-width: 97;
    -fx-pref-height: 30;
    -fx-font-size: 15px;
}

#tabPending .tab-label {
	-fx-font-family: delicious-bold;
	-fx-text-fill: brown;    
}

#tabOverdue .tab-label {
	-fx-font-family: delicious-bold;
	-fx-text-fill: purple;    
}

#tabCompleted .tab-label {
 	-fx-font-family: delicious-bold;
	-fx-text-fill: dimgrey;    
}

#tabToday .tab-label {
	-fx-font-family: delicious-bold;
	-fx-text-fill: red;    
}

#tabTomorrow .tab-label {
	-fx-font-family: delicious-bold;
	-fx-text-fill: firebrick;    
}

#tabOthers .tab-label {
	-fx-font-family: delicious-bold;
	-fx-text-fill: teal;    
}

#tabFloat .tab-label {
	-fx-font-family: delicious-bold;
	-fx-text-fill: dodgerblue;  
}

.tab-pane .tab:selected {
   -fx-background-color: rgb(255, 255, 255, 1);
   -fx-opacity: 1;
}

#imageView {
	-fx-effect: dropshadow( gaussian , rgba(0,0,0,0.2) , 2,1,3,3 );
}

.borderPane {
    -fx-max-width: 1020px;
}

#quote {
     -fx-font-family: "Aileron Thin Italic";
     -fx-font-size: 20px;
     -fx-fill: white;
}

/** list **/
#todoList {
	-fx-background-color: rgb(255, 255, 255, 1);
    -fx-font-size: 18px;
    -fx-font-family: delicious-roman;
    -fx-border-radius: 10 10 10 10;
    -fx-background-radius: 10 10 10 10;
    -fx-padding: 10;
}

.list-view:focused{
	-fx-border-color: lightblue;
	-fx-border-width: 2;
}

.label {
	-fx-text-fill: black;
}

/* Hide scroll bars */
#todoList .scroll-bar:horizontal, .scroll-bar:vertical {
    -fx-opacity: 0;
    -fx-padding: -7;
}

.table-view .scroll-bar:horizontal, .scroll-bar:vertical {
	-fx-opacity: 0;
    -fx-padding: -7;
}

.list-cell #taskOverdue {   
    -fx-border-width: 0 0 0 5;
    -fx-border-color: purple;
}

.list-cell #taskToday {   
    -fx-border-width: 0 0 0 5;
    -fx-border-color: red;
}

.list-cell #taskTomorrow {
	 -fx-border-width: 0 0 0 5;
    -fx-border-color: firebrick;
}

.list-cell #taskFloat {   
    -fx-border-width: 0 0 0 5;
    -fx-border-color: dodgerblue;
}

.list-cell #taskOthers {
	-fx-border-width: 0 0 0 5;
    -fx-border-color: teal;
}

.list-cell {
    -fx-background-color: transparent;
    -fx-text-fill: white;    
}

.list-cell:selected {
    -fx-background-color: beige;
    -fx-text-fill: darkorange;    
}

#classOverdue {
	-fx-font-family: "Aileron Bold";
	-fx-text-fill: purple;    
	-fx-font-size: 16px;
}

#classToday {
	-fx-font-family: "Aileron Bold";
	-fx-text-fill: red;    
	-fx-font-size: 16px;
}

#classTomorrow {
	-fx-font-family: "Aileron Bold";
	-fx-text-fill: firebrick;    
	-fx-font-size: 16px;
}

#classOthers {
	-fx-font-family:"Aileron Bold";
	-fx-text-fill: teal;    
	-fx-font-size: 16px;
}

#classFloat {
	-fx-font-family: "Aileron Bold";
	-fx-text-fill: dodgerblue;    
	-fx-font-size: 16px;
}

#numTask {
	-fx-font-size: 14px;
}


#taskIndex {
	-fx-font-size: 20px;
}

#taskTime {
	-fx-font-family: delicious-roman;
	-fx-font-size: 16px;
	-fx-text-fill: darkorange;
}

#taskDate {
	-fx-font-family: delicious-roman;
	-fx-font-size: 16px;
	-fx-text-fill: crimson;
}

/** user input feedback **/
#feedbackMain {
	-fx-font-family: "Aileron Bold";
    -fx-font-size: 20px;
    -fx-fill: white;
}

#feedbackHelp {
	-fx-font-family: "Aileron Semi Bold";
    -fx-font-size: 14px;
    -fx-fill: beige;
}

.text-field {
	-fx-background-color: rgb(255, 255, 255, 0.4);
	-fx-background-radius: 20 20 20 20;
	-fx-font-family: delicious-bold;
	-fx-font-size: 20px;
	-fx-prompt-text-fill: rgb(0, 0, 0, 0.3);
}

.text-field:focused {
	-fx-prompt-text-fill: rgb(0, 0, 0, 0);
}

#completedTaskName .text {
	-fx-strikethrough: true;
}

#tutorialContainer {
	-fx-font-size: 17px;
	-fx-font-family: delicious-roman;
}

#exitMessage {
	-fx-font-size: 14px;
}

#tutorialSamples {
	-fx-font-family: Monospaced;
	-fx-font-size: 14px;
	-fx-fill: orangered;
}

#emptyRow {
	-fx-opacity: 0.6;
	-fx-alignment: center;
	-fx-padding: 90 0 0 0;
}
```
###### \ui\Controllers\AutoCompleteCommands.java
``` java
package ui.Controllers;

import java.util.ArrayList;

import javafx.scene.control.TextField;
import javafx.scene.text.Text;

public class AutoCompleteCommands {
	
	/**
	 * This class retrieves the text field and corrects/completes the text in the text field
	 * It also parses the partial text in the text field via string manipulation
	 * It maintains a list of commands with is used to compare with the partial text in 
	 * the text field
	 * 
	 */
	
	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_UNMARK = "unmark";
	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_REDO = "redo";
	private static final String COMMAND_MARK = "mark";
	private static final String COMMAND_HELP = "help";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_DISPLAY = "display";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_CLEAR = "clear";
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_SAVE = "save";
	
	private static final String SPACE_REGEX = " ";
	
	private static final int START_INDEX = 0;
	private static final int END_INDEX = 1;
	private static final int END_INDEX_DISPLAY = 2;
	private static final int END_INDEX_SAVE = 2;
	private static final int END_INDEX_UNMARK = 3;
	
	private static ArrayList<String> autoCompleteList = new ArrayList<String>();
	
	private static void initAutoComplete() {
		autoCompleteList.add(COMMAND_ADD);
		autoCompleteList.add(COMMAND_CLEAR);
		autoCompleteList.add(COMMAND_DELETE);
		autoCompleteList.add(COMMAND_EDIT);
		autoCompleteList.add(COMMAND_HELP);
		autoCompleteList.add(COMMAND_MARK);
		autoCompleteList.add(COMMAND_UNDO);
		autoCompleteList.add(COMMAND_REDO);
		autoCompleteList.add(COMMAND_SEARCH);
	}
	
	/**
	 * Auto completes and corrects command input by users
	 * @param userInput This is the user input from commandLineInterface
	 * @param feedback This is the main feedback from commandLineInterface
	 */
	public static void autoComplete(TextField userInput, Text feedback) {
		initAutoComplete();
		String autoCompleteCheck = processUserInput(userInput, feedback);
		checkCommandMatch(userInput, feedback, autoCompleteCheck);
	}

	private static String processUserInput(TextField userInput, Text feedback) {
		String autoCompleteCheck = userInput.getText();
		autoCompleteCheck = checkValidUserInput(userInput, feedback, autoCompleteCheck);
		return autoCompleteCheck;
	}
	
	/**
	 * 
	 * @param userInput This is the entire text field
	 * @param feedback This is the string to be displayed to the user
	 * @param autoCompleteCheck This is the input in the text field
	 */
	private static void checkCommandMatch(TextField userInput, Text feedback, String autoCompleteCheck) {
		for(int i = 0; i < autoCompleteList.size(); i++) {
			if(autoCompleteCheck.equals(autoCompleteList.get(i).substring(START_INDEX, END_INDEX))) {
				int currentCaretPosition = userInput.getCaretPosition();
				String splitInput[] = userInput.getText().split(SPACE_REGEX);
				checkConflictingCommands(userInput, i, splitInput);
				
				StringBuilder sb = new StringBuilder();
				rebuildCorrectedUserInput(splitInput, sb);
				
				userInput.setText(sb.toString().trim());
				fixCaretFinalPosition(userInput, currentCaretPosition, splitInput);
				
				FeedbackGenerator.generateAutoCompleteFeedback(feedback, splitInput[START_INDEX]);
				break;
			}	
		}
	}
	
	private static void fixCaretFinalPosition(TextField userInput, int currentCaretPosition, String[] splitInput) {
		if(splitInput.length == 1) {
			userInput.end();
		} else {
			userInput.positionCaret(currentCaretPosition);
		}
	}

	private static String checkValidUserInput(TextField userInput, Text feedback, String autoCompleteCheck) {
		if(autoCompleteCheck.isEmpty()) {
			FeedbackGenerator.generateNullFeedback(feedback);
		} else {
			autoCompleteCheck = userInput.getText(START_INDEX, END_INDEX);
		}
		return autoCompleteCheck;
	}

	private static void rebuildCorrectedUserInput(String[] splitInput, StringBuilder sb) {
		for (String string : splitInput) {
			sb.append(string);
			if (sb.length() > 0) {
				sb.append(SPACE_REGEX);
			}
		}
	}
	
	/**
	 * Resolve any partial inputs that has conflicting initials
	 * @param userInput This is the entire text field
	 * @param i This is the list current list index
	 * @param splitInput This is the array of words to be rebuilt
	 */
	private static void checkConflictingCommands(TextField userInput, int i, String[] splitInput) {
		if(isEstimatedCommandDisplay(userInput, splitInput)) {
			splitInput[START_INDEX] = COMMAND_DISPLAY;
		} else if(isEstimatedCommandSave(userInput, splitInput)) {
			splitInput[START_INDEX] = COMMAND_SAVE;
		} else if(isEstimatedCommandUnmark(userInput, splitInput)) {
			splitInput[START_INDEX] = COMMAND_UNMARK;
		} else {
			splitInput[START_INDEX] = autoCompleteList.get(i);
		}
	}

	private static boolean isEstimatedCommandUnmark(TextField userInput, String[] splitInput) {
		return splitInput[START_INDEX].length() > END_INDEX_UNMARK-1
				&& userInput.getText(START_INDEX, END_INDEX_UNMARK).
				equals(COMMAND_UNMARK.substring(START_INDEX, END_INDEX_UNMARK));
	}
	
	private static boolean isEstimatedCommandSave(TextField userInput, String[] splitInput) {
		return splitInput[START_INDEX].length() > END_INDEX_SAVE-1 
				&& userInput.getText(START_INDEX, END_INDEX_SAVE).
				equals(COMMAND_SAVE.substring(START_INDEX, END_INDEX_SAVE));
	}

	private static boolean isEstimatedCommandDisplay(TextField userInput, String[] splitInput) {
		return splitInput[START_INDEX].length() > END_INDEX_DISPLAY-1 
				&& userInput.getText(START_INDEX, END_INDEX_DISPLAY).
				equals(COMMAND_DISPLAY.substring(START_INDEX, END_INDEX_DISPLAY));
	}
}
```
###### \ui\Controllers\ColorRenderer.java
``` java
package ui.Controllers;

import javafx.scene.Node;

public class ColorRenderer {
	
	/**
	 * This class functions to change the background color of the application  
	 * It also maintains a color toggle and parses the toggle
	 * The color change depends on the value of the toggle
	 * 
	 */
	
	private static final String INVALID_COLOR = "-fx-background: #FFFFFF"; 	
	private static final String ORANGE_COLOR = "-fx-background-color: linear-gradient(orangered, orange)"; 		
	private static final String MAROON_COLOR = "-fx-background-color: linear-gradient(maroon, goldenrod)";
	private static final String BROWN_COLOR = "-fx-background-color: linear-gradient(sienna, burlywood)";
	private static final String CORAL_COLOR = "-fx-background-color: linear-gradient(coral, plum)";
	private static final String TURQOISE_COLOR = "-fx-background-color: linear-gradient(teal, turquoise)";
	private static final String OLIVE_COLOR = "-fx-background-color: linear-gradient(darkolivegreen, mediumseagreen)";
	private static final String ORCHID_COLOR = "-fx-background-color: linear-gradient(blueviolet, firebrick)";
	
	private static final int OLIVE_FLAG = -3;
	private static final int TURQOISE_FLAG = -2;
	private static final int ORCHID_FLAG = -1;
	private static final int ORANGE_FLAG = 0; 
	private static final int CORAL_FLAG = 1;
	private static final int MAROON_FLAG = 2;
	private static final int BROWN_FLAG = 3;
	
	private static final int MAX_FLAG = 3;
	private static final int MIN_FLAG = -3;
	private static final int INIT_FLAG = 0;

	private int colorToggle;

	/**
	 * Constructor method
	 */
	public ColorRenderer() {
		colorToggle = INIT_FLAG;
	}
	
	/**
	 * Increases the color toggle flag
	 * @param node This is the background node for the application
	 */
	public void toggleColorPlus(Node node) {
		colorToggle++;
		if(colorToggle > MAX_FLAG) {
			colorToggle = MAX_FLAG;
		}
		setBackgroundColor(node);
	}
	
	/**
	 * Decreases the color toggle flag
	 * @param node This is the background node for the application
	 */
	public void toggleColorMinus(Node node) {
		colorToggle--;
		if(colorToggle < MIN_FLAG) {
			colorToggle = MIN_FLAG;
		}
		setBackgroundColor(node);
	}

	private void setBackgroundColor(Node node) {
		switch(colorToggle) {
		case OLIVE_FLAG:
			node.setStyle(OLIVE_COLOR);
			break;
		case TURQOISE_FLAG:
			node.setStyle(TURQOISE_COLOR);
			break;
		case ORCHID_FLAG:
			node.setStyle(ORCHID_COLOR);
			break;
		case ORANGE_FLAG:
			node.setStyle(ORANGE_COLOR);
			break;
		case CORAL_FLAG:	
			node.setStyle(CORAL_COLOR);
			break;
		case MAROON_FLAG:
			node.setStyle(MAROON_COLOR);
			break;
		case BROWN_FLAG:
			node.setStyle(BROWN_COLOR);
			break;
		default:
			node.setStyle(INVALID_COLOR);
			break;
		}
	}

}
```
###### \ui\Controllers\CommandLineController.java
``` java
package ui.Controllers;

import java.io.IOException;

import javafx.util.Duration;

import java.util.ArrayList;
import java.util.logging.Logger;

import javafx.animation.FadeTransition;
import javafx.fxml.FXML;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.text.Text;
import shared.LogHandler;

public class CommandLineController {

	/**
	 * 	ConmmandLineController controls the to-do list
	 * 	Primarily functions to retrieve inputs on the command line (both keystrokes and hotkeys) 
	 *  and manipulates the command line
	 * 	It also auto-completes/-corrects user input, display feedback and set previous/recent user commands
	 * 	into the command line by calling other sub classes
	 * 
	 */
	
	private static final String TUTORIAL_OFF_STRING = "OFF";
	private static final String TUTORIAL_ON_STRING = "ON";
	private static final boolean TUTORIAL_ON = true;
	private static final boolean TUTORIAL_OFF = false;

	private static final String SPACE_REGEX = " ";
	private static final String INITIALIZE = "";

	private static final String COMMAND_UNDO = "undo";
	private static final String COMMAND_UNMARK = "unmark";
	private static final String COMMAND_SEARCH = "search";
	private static final String COMMAND_REDO = "redo";
	private static final String COMMAND_MARK = "mark";
	private static final String COMMAND_EDIT = "edit";
	private static final String COMMAND_DISPLAY = "display";
	private static final String COMMAND_DELETE = "delete";
	private static final String COMMAND_ADD = "add";
	private static final String COMMAND_SAVE = "save";

	private static final int START_INPUT_INDEX = 0;
	private static final int FIRST_TAB = 0;
	private static final int COMPLETE_TAB = 1;
	private static final int MIN_TASK_LIST_SIZE = 1;
	private static final int FEEDBACK_ANIMATION_DURATION = 200;
	
	private boolean tutorialToggle = TUTORIAL_ON;

	@FXML private Text feedbackMain;
	@FXML private Text feedbackHelp;
	@FXML public TextField userInput;
	
	private String command = INITIALIZE;
	private int index = START_INPUT_INDEX;
	private int tabToggle = COMPLETE_TAB;

	private ArrayList<String> inputArray;
	private Logger log = LogHandler.retrieveLog();

	private ColorRenderer backgroundColor;
	private SupportFeaturesHandler supportFeaturesHandler;
	private MainGUIController main;

	/**
	 * Constructor method
	 * @param mainController The primary controller linking this and the other controllers
	 */
	public void init(MainGUIController mainController) {
		main = mainController;
		inputArray = new ArrayList<String>();
		backgroundColor = new ColorRenderer();
		supportFeaturesHandler = new SupportFeaturesHandler(main);
		FeedbackGenerator.generateDefaultFeedback(feedbackMain);

		initCommandLineListener();
	}

	private void initCommandLineListener() {
		userInput.textProperty().addListener((observable, oldValue, newValue) -> {
			if(newValue.trim().isEmpty()) {
				FeedbackGenerator.clearFeedback(feedbackHelp);
			} else if(newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_ADD)) {
				FeedbackGenerator.generateAddFeedback(feedbackHelp);
			} else if (newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_DELETE)) {
				FeedbackGenerator.generateDeleteFeedback(feedbackHelp);
			} else if (newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_EDIT)) {
				FeedbackGenerator.generateEditFeedback(feedbackHelp);
			} else if (newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_MARK)) {
				FeedbackGenerator.generateMarkFeedback(feedbackHelp);
			} else if (newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_UNMARK)) {
				FeedbackGenerator.generateUnmarkFeedback(feedbackHelp);
			} else if (newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_SEARCH)) {
				FeedbackGenerator.generateSearchFeedback(feedbackHelp);
			} else if (newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_REDO)) {
				if(inputArray.size() >= 2 && inputArray.get(inputArray.size()-1).equalsIgnoreCase(COMMAND_UNDO)) {
					FeedbackGenerator.generateRedoFeedback(feedbackHelp, inputArray.get(inputArray.size()-2));
				} else {
					FeedbackGenerator.generateInvalidHelpFeedback(feedbackHelp);
				}
			} else if (newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_UNDO)) {
				if(inputArray.size() >= 1) {
					FeedbackGenerator.generateUndoFeedback(feedbackHelp, inputArray.get(inputArray.size()-1));
				} else {
					FeedbackGenerator.generateInvalidHelpFeedback(feedbackHelp);
				}
			} else if (newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_DISPLAY)) {
				FeedbackGenerator.generateHelpFeedback(feedbackHelp);
			} else if (newValue.split(SPACE_REGEX)[START_INPUT_INDEX].equalsIgnoreCase(COMMAND_SAVE)) {
				FeedbackGenerator.generateHelpFeedback(feedbackHelp);
			} else {
				FeedbackGenerator.generateHelpFeedback(feedbackHelp);
				FeedbackGenerator.generateTipFeedback(feedbackMain);
			}

		});
	}

	@FXML 
	private void handleSubmitButtonAction(KeyEvent event) throws IOException {
		parseKeyEvent(event);
	}

	private void parseKeyEvent(KeyEvent event) throws IOException {
		if (event.getCode() == KeyCode.ENTER) {
			processUserInput(event);
		} else if(event.getCode() == KeyCode.UP) {
			getPreviousCommand();
		} else if(event.getCode() == KeyCode.DOWN) {
			getNextCommand();	
		} else if(event.getCode() == KeyCode.RIGHT) {
			if(event.isAltDown()) {
				changeBackgroundColorIncrementally();
			} else if(event.isShiftDown()) {
				updateTutorialToggle();
			} else {
				nextTutorialPage();
			}
		} else if(event.getCode() == KeyCode.LEFT) {
			if(event.isAltDown()) {
				changeBackgroundColorDecrementally();
			}
		} else if (event.getCode() == KeyCode.F1) {
			changeTabFocus();
		} else if(event.getCode() == KeyCode.SPACE) {
			AutoCompleteCommands.autoComplete(userInput, feedbackMain);
		}
	}

	private void changeBackgroundColorDecrementally() {
		backgroundColor.toggleColorMinus(main.getBackgroundPane());
	}

	private void changeBackgroundColorIncrementally() {
		backgroundColor.toggleColorPlus(main.getBackgroundPane());
	}

	private void processUserInput(KeyEvent event) throws IOException {
		event.consume();
		readUserInput();

		if(!supportFeaturesHandler.isSupportFeaturesLoaded(feedbackMain)) {
			main.refreshToDoList();
		}
	}

	private void changeTabFocus() {
		main.getTabPane().getSelectionModel().select(tabToggle);
		tabToggle++;
		if (tabToggle == main.getTabPane().getTabs().size()) {
			tabToggle = FIRST_TAB;
		}
	}

	private void nextTutorialPage() throws IOException {
		if(tutorialToggle == TUTORIAL_ON && main.getTaskList().isEmpty()) {
			main.refreshToDoList();
			main.startTutorialMode();
			tutorialToggle = TUTORIAL_OFF;
		}
	}
	
	/**
	 * Passes the user input to Logic
	 * @param input This is the user input
	 * @return String This is the feedback from Logic
	 */
	public String uiToLogic(String input) {
		return main.passInputToLogic(input);
	}

	private void readUserInput() {
		command = userInput.getText();
		log.info("User Input: " + command);
		
		loadFeedback();
		userInput.clear();
		inputArray.add(command);
		index++;
	}

	private void loadFeedback() {
		feedbackMain.setText(uiToLogic(command));
		log.info("Feedback from Logic: " + feedbackMain.getText());

		FadeTransition ft = new FadeTransition(Duration.millis(FEEDBACK_ANIMATION_DURATION), feedbackMain);
		ft.setFromValue(0);
		ft.setToValue(1);
		ft.play();
	}

	private void updateTutorialToggle() {
		if(main.getTaskList().size() == MIN_TASK_LIST_SIZE) {
			if(tutorialToggle) {
				tutorialToggle = TUTORIAL_OFF;
			} else {
				tutorialToggle = TUTORIAL_ON;
			}
			main.openMainPane();
		}
	}

	private void getNextCommand() {
		if(index >= 0 && index < inputArray.size()-1) {
			userInput.setText(inputArray.get(++index));
			if(index == inputArray.size()-1) {
				index++;
			}
		} else if(index >= inputArray.size()-1) {
			userInput.clear();
			index = inputArray.size();
		}
	}

	private void getPreviousCommand() {
		if(index > 0 && index <= inputArray.size()) {
			userInput.setText(inputArray.get(--index));
		}
	}
	
	/**
	 * Gets user input field from commandLineController
	 * @return TextField This is the user input field
	 */
	public TextField getCommandLine() {
		return userInput;
	}

	/**
	 * Gets main feedback from commandLineController
	 * @return Text main feedback
	 */
	public Text getMainFeedback() {
		return feedbackMain;
	}

	/**
	 * Gets secondary feedback from commandLineController
	 * @return Text secondary feedback
	 */
	public Text getHelpFeedback() {
		return feedbackHelp;
	}
	
	/**
	 * Gets tutorial flag in string from commandLineController
	 * @return String Flag for indication of whether tutorial is ON or OFF
	 */
	public String getTutorialToggle() {
		if(tutorialToggle) {
			return TUTORIAL_ON_STRING;
		} else {
			return TUTORIAL_OFF_STRING;
		}
	}
}
```
###### \ui\Controllers\CommandLineControllerTest.java
``` java
package ui.Controllers;

import static org.junit.Assert.*;

import org.junit.Test;

public class CommandLineControllerTest {

	private static final String MESSAGE_ADD_SUCCESS = "The event has been added.";
	private static final String MESSAGE_CLEAR_SUCCESS = "Your dashboard has been cleared.";
	private static final String MESSAGE_DELETE_SUCCESS = "The event has been deleted.";
	private static final String MESSAGE_SAVEAS_SUCCESS = "Displaying file explorer";
	private static final String MESSAGE_DISPLAY_SUCCESS = "Displaying Events";
	private static final String MESSAGE_DISPLAY_FAILURE = "Unable to display.";
	private static final String MESSAGE_MARK_COMPLETE_SUCCESS = "Event marked completed.";
	private static final String MESSAGE_MARK_COMPLETE_FAILURE = "Unable to mark task as complete.";
	private static final String MESSAGE_MARK_INCOMPLETE_SUCCESS = "Event marked as incomplete.";
	private static final String MESSAGE_MARK_INCOMPLETE_FAILURE = "Unable to mark event as incomplete.";
	private static final String MESSAGE_SEARCH_SUCCESS = "Your search query has returned:";
	private static final String MESSAGE_EDIT_SUCCESS = "The event has been edited.";
	private static final String MESSAGE_EDIT_FAILURE = "Unable to edit event.";
	private static final String MESSAGE_TUTORIAL_DEFAULT = "Displaying Tutorial";
	private static final String MESSAGE_CALENDAR_DEFAULT = "Displaying Calendar";
	private static final String MESSAGE_HELP_SUCCESS = "Displaying Help";
	
	private static final String MESSAGE_INVALID = "Invalid command";
	
	private MainGUIController main = new MainGUIController();
	
	static String expectedResults;
	static String input;
	
	public void testClear() {
		input = "clear";
		expectedResults = MESSAGE_CLEAR_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "clear none";
		expectedResults = MESSAGE_CLEAR_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
	
	@Test
	public void testAdd() {
		
		input = "add machine number 500";
		expectedResults = MESSAGE_ADD_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "add cs2103 1700  23/04/2016";
		expectedResults = MESSAGE_ADD_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "add cs2103 2500  23/04/2016";
		expectedResults = MESSAGE_ADD_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "add cs2103 -0100  23/04/2016";
		expectedResults = MESSAGE_ADD_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "add cs2103 0200  32/04/2016";
		expectedResults = MESSAGE_ADD_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "add cs2103 0200  -2/04/2016";
		expectedResults = MESSAGE_ADD_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "add add";
		expectedResults = MESSAGE_ADD_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "add cs2103 -t 1700";
		expectedResults = MESSAGE_ADD_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = " add delete 0";
		expectedResults = MESSAGE_INVALID;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "dont add";
		expectedResults = MESSAGE_INVALID;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
	}
	
	@Test
	public void testDelete() {
		
		input = "delete 1";
		expectedResults = MESSAGE_DELETE_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "delete all";
		expectedResults = MESSAGE_INVALID;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "dont delete";
		expectedResults = MESSAGE_INVALID;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
	
	@Test
	public void testEdit() {
		input = "edit 1 hello";
		expectedResults = MESSAGE_EDIT_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "edit -1 bye";
		expectedResults = MESSAGE_INVALID;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "edit 1000 awesome";
		expectedResults = MESSAGE_EDIT_FAILURE;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
	
	@Test
	public void testSearch() {
		input = "search a";
		expectedResults = MESSAGE_SEARCH_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "search &*)*";
		expectedResults = MESSAGE_SEARCH_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
	
	@Test
	public void testMark() {
		input = "mark 2";
		expectedResults = MESSAGE_MARK_COMPLETE_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "mark -1";
		expectedResults = MESSAGE_INVALID;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "mark 10000";
		expectedResults = MESSAGE_MARK_COMPLETE_FAILURE;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
	
	@Test
	public void testUnmark() {
		input = "unmark -1";
		expectedResults = MESSAGE_MARK_INCOMPLETE_FAILURE;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "unmark 1";
		expectedResults = MESSAGE_MARK_INCOMPLETE_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "unmark 1000";
		expectedResults = MESSAGE_MARK_INCOMPLETE_FAILURE;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
	
	@Test
	public void testDisplay() {
		input = "display 0";
		expectedResults = MESSAGE_DISPLAY_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "display 1";
		expectedResults = MESSAGE_DISPLAY_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "display 2";
		expectedResults = MESSAGE_DISPLAY_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "display 3";
		expectedResults = MESSAGE_DISPLAY_FAILURE;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
	}
	
	@Test
	public void testTutorial() {
		input = "tutorial 0";
		expectedResults = MESSAGE_TUTORIAL_DEFAULT;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "tutorial";
		expectedResults = MESSAGE_TUTORIAL_DEFAULT;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
	
	@Test
	public void testCalendar() {
		input = "calendar 0";
		expectedResults = MESSAGE_CALENDAR_DEFAULT;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "calendar";
		expectedResults = MESSAGE_CALENDAR_DEFAULT;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
	
	@Test
	public void testHelp() {
		input = "help 0";
		expectedResults = MESSAGE_HELP_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "help";
		expectedResults = MESSAGE_HELP_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
	
	@Test
	public void testSaveAs() {
		input = "saveAs";
		expectedResults = MESSAGE_INVALID;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "saveas 0";
		expectedResults = MESSAGE_INVALID;
		assertEquals(expectedResults, main.passInputToLogic(input));
		
		input = "saveas";
		expectedResults = MESSAGE_SAVEAS_SUCCESS;
		assertEquals(expectedResults, main.passInputToLogic(input));
	}
}
```
###### \ui\Controllers\FeedbackGenerator.java
``` java
package ui.Controllers;

import javafx.scene.text.Text;

public class FeedbackGenerator {
	
	/**
	 * This class is a storage of feedbacks
	 * It generates feedback to be displayed to the user
	 * 
	 */

	private static final String FEEDBACK_COMMANDS = 
			"add | clear | delete | display| edit | help | mark | redo | save | search | unmark | undo";
	private static final String FEEDBACK_ADD = "add [task] [date] [time]";
	private static final String FEEDBACK_DELETE = "delete [task number]";
	private static final String FEEDBACK_EDIT = "edit [task number] [new task] [new date] [new time]";
	private static final String FEEDBACK_MARK = "mark [task number]";
	private static final String FEEDBACK_UNMARK = "unmark [task number]";
	private static final String FEEDBACK_SEARCH = "search [keyword]";
	private static final String FEEDBACK_REDO = "Your last input before undo was '%1s'";
	private static final String FEEDBACK_UNDO = "Your last input was '%1s'";
	private static final String FEEDBACK_INVALID = "The command you are about to input will not generate changes'";
	private static final String FEEDBACK_EVENT_CLASH = "There is a clash in your event tasks";
	
	private static final String MAIN_FEEDBACK_DEFAULT = "How can I be of help?";
	private static final String MAIN_FEEDBACK_INVALID = "Unrecognised command";
	private static final String MAIN_FEEDBACK_EMPTY = "Awaiting your orders";
	private static final String MAIN_FEEDBACK_TIP = "Press SPACE to complete or correct your commands";

	private static final String MAIN_FEEDBACK_AUTOCOMPLETE = "Is '%1s' what you meant?";
	

	private static final String NULL_REGEX = "";

	/**
	 * Generates are default feedback
	 * @param feedback This is the main feedback from commandListInterface
	 */
	public static void generateDefaultFeedback(Text feedback) {
		feedback.setText(String.format(MAIN_FEEDBACK_DEFAULT));
	}
	
	/**
	 * Generates feedback after auto complete
	 * @param feedback
	 * @param command
	 */
	public static void generateAutoCompleteFeedback(Text feedback, String command) {
		feedback.setText(String.format(MAIN_FEEDBACK_AUTOCOMPLETE, command));
	}

	/**
	 * Generates are add feedback
	 * @param feedback This is the secondary feedback from commandListInterface
	 */
	public static void generateAddFeedback(Text feedback) {
		feedback.setText(FEEDBACK_ADD);
	}
	
	/**
	 * Generates are delete feedback
	 * @param feedback This is the secondary feedback from commandListInterface
	 */
	public static void generateDeleteFeedback(Text feedback) {
		feedback.setText(FEEDBACK_DELETE);
	}
	
	/**
	 * Generates are edit feedback
	 * @param feedback This is the secondary feedback from commandListInterface
	 */
	public static void generateEditFeedback(Text feedback) {
		feedback.setText(FEEDBACK_EDIT);
	}
	
	/**
	 * Generates feedback for mark
	 * @param feedback This is the secondary feedback from commandListInterface
	 */
	public static void generateMarkFeedback(Text feedback) {
		feedback.setText(FEEDBACK_MARK);
	}

	/**
	 * Generates feedback for unmark
	 * @param feedback This is the secondary feedback from commandListInterface
	 */
	public static void generateUnmarkFeedback(Text feedback) {
		feedback.setText(FEEDBACK_UNMARK);
	}
	
	/**
	 * Generates feedback for search
	 * @param feedback This is the main feedback from commandListInterface
	 */
	public static void generateSearchFeedback(Text feedback) {
		feedback.setText(FEEDBACK_SEARCH);
	}
	
	/**
	 * Generates feedback for invalid
	 * @param feedback This is the secondary feedback from commandListInterface
	 */
	public static void generateInvalidHelpFeedback(Text feedback) {
		feedback.setText(FEEDBACK_INVALID);
	}
	
	/**
	 * Generates feedback for invalid 
	 * @param feedback This is the main feedback from commandListInterface
	 */
	public static void generateInvalidMainFeedback(Text feedback) {
		feedback.setText(MAIN_FEEDBACK_INVALID);
	}
	
	/**
	 * Generates feedback for empty input
	 * @param feedback This is the main feedback from commandListInterface
	 */
	public static void generateNullFeedback(Text feedback) {
		feedback.setText(MAIN_FEEDBACK_EMPTY);
	}
	
	/**
	 * Generates assisting feedback feedback
	 * @param feedback This is the main feedback from commandListInterface
	 */
	public static void generateHelpFeedback(Text feedback) {
		feedback.setText(FEEDBACK_COMMANDS);
	}
	
	/**
	 * Generates are tip for feedback
	 * @param feedback This is the main feedback from commandListInterface
	 */
	public static void generateTipFeedback(Text feedback) {
		feedback.setText(MAIN_FEEDBACK_TIP);
	}
	
	/**
	 * Generates feedback for redo
	 * @param feedback
	 * @param lastInput This is the input prior to undo
	 */
	public static void generateRedoFeedback(Text feedback, String lastInput) {
		feedback.setText(String.format(FEEDBACK_REDO, lastInput));
	}
	
	/**
	 * Generates feedback for undo
	 * @param feedback This is the secondary feedback from commandListInterface
	 * @param lastInput This is the most recent input
	 */
	public static void generateUndoFeedback(Text feedback, String lastInput) {
		feedback.setText(String.format(FEEDBACK_UNDO, lastInput));
	}
	
	/**
	 * Generates feedback for event clashes
	 * @param feedback This is the secondary feedback from commandListInterface
	 */
	public static void generateEventClashFeedback(Text feedback) {
		feedback.setText(FEEDBACK_EVENT_CLASH);
	}

	/**
	 * Clears the text from feedback
	 * @param feedback This is the main feedback from commandListInterface
	 */
	public static void clearFeedback(Text feedback) {
		feedback.setText(NULL_REGEX);
	}
}
```
###### \ui\Controllers\HelpCommands\Help.java
``` java
package ui.Controllers.HelpCommands;

public class Help {
	
    private String helpCommand;
    private String helpFormat;
    
    /**
     * Constructor method
     * @param command This is the command name
     * @param format This is the format for the command
     */
    public Help(String command, String format) {
        this.helpCommand = command;
        this.helpFormat = format; 
    }
 
    /**
     * Gets command name
     * @return the command name
     */
    public String getHelpCommand() {
        return this.helpCommand;
    }
        
    /**
     * Gets command format
     * @return the command format
     */
    public String getHelpFormat() {
        return this.helpFormat;
    }
    
    /**
     * Sets the command name
     * @param command This is the command name
     */
    public void setHelpCommand(String command) {
        this.helpCommand = command;
     }
    
    /**
     * Sets the command format
     * @param format This is the command format
     */
    public void setHelpFormat(String format) {
        this.helpFormat = format;
    }
}
```
###### \ui\Controllers\HelpCommands\HelpCommandStorage.java
``` java
package ui.Controllers.HelpCommands;

import java.util.ArrayList;

public class HelpCommandStorage {

	/**
	 * This class stores all the help commands
	 * It generates the help list but does not display any of them
	 * It returns the entire help command list to its caller
	 * 
	 */
	
	private static final String NULL_REGEX = "";
	private static final String KEYBOARD_HEADING = "COMMANDS";
	private static final String HOTKEYS_HEADING = "HOTKEYS";

	private static final String HELP_ADD_DETAILS = "add task to list";
	private static final String HELP_CALENDAR_DETAILS = "display time and calendar";
	private static final String HELP_CLEAR_DETAILS = "clear list";
	private static final String HELP_DELETE_DETAILS = "delete task from list";
	private static final String HELP_DISPLAY_DETAILS = "display list of tasks";
	private static final String HELP_EDIT_DETAILS = "edit task in list";
	private static final String HELP_MARK_DETAILS = "mark task as completed";
	private static final String HELP_REDO_DETAILS = "redo more recent action";
	private static final String HELP_SAVEAS_DETAILS = "change save location";
	private static final String HELP_SEARCH_DETAILS = "search tasks with keywords";
	private static final String HELP_TUTORIAL_DETAILS = "display step-by-step tutorial";
	private static final String HELP_UNDO_DETAILS = "undo previous action";
	private static final String HELP_UNMARK_DETAILS = "mark task as incomplete";

	private static final String HELP_AUTOCOMPLETE_DETAILS = "complete your command";
	private static final String HELP_PREVIOUS_COMMAND_DETAILS = "get previous command";
	private static final String HELP_QUIT_DETAILS = "quit application";
	private static final String HELP_RECENT_COMMAND_DETAILS = "get more recent command";
	private static final String HELP_TOGGLE_COLORS_DETAILS = "toggle background colors";
	private static final String HELP_TOGGLE_INTERFACE_DETAILS = "toggle interface selection";
	private static final String HELP_TOGGLE_TABS_DETAILS = "toggle filter tabs";

	private static final String HELP_ADD_FORMAT = "add [task]\n"
			+ "add [task] [time] [date]\n"
			+ "add [task] [start time] [end time]\n"
			+ "[start date] [end date]\n";
	private static final String HELP_CLEAR_FORMAT = "clear";
	private static final String HELP_DELETE_FORMAT = "delete [task number]";
	private static final String HELP_EDIT_FORMAT = "edit [task]\n"
			+ "edit [time]\n"
			+ "edit [date]\n";
	private static final String HELP_MARK_FORMAT = "mark [task number]";
	private static final String HELP_UNMARK_FORMAT = "unmark [task number]";
	private static final String HELP_SEARCH_FORMAT = "search [key words]";
	private static final String HELP_SAVEAS_FORMAT = "saveas\n"
			+ "save [file path]";
	private static final String HELP_DISPLAY_FORMAT = "display 0 (incomplete)\n"
			+ "display 1 (complete)\n"
			+ "display 2 (all)";
	private static final String HELP_UNDO_FORMAT = "undo";
	private static final String HELP_REDO_FORMAT = "redo";
	private static final String HELP_CALENDAR_FORMAT = "calendar";
	private static final String HELP_TUTORIAL_FORMAT = "tutorial";

	private static final String HELP_QUIT_KEYS = "ESC";
	private static final String HELP_TOGGLE_COLORS_KEYS = "ALT + RIGHT\n"
			+ "ALT + LEFT";
	private static final String HELP_PREVIOUS_COMMAND_KEYS = "UP";
	private static final String HELP_RECENT_COMMAND_KEYS = "DOWN";
	private static final String HELP_AUTOCOMPLETE_KEYS = "SPACE";
	private static final String HELP_TOGGLE_INTERFACE_KEYS = "TAB";
	private static final String HELP_TOGGLE_TABS_KEYS = "F1";

	private static final int HELP_LIST_SIZE = 23;
	private static final int INITIALIZE_INDEX = -1;

	private static ArrayList<ArrayList<String>> helpList = new ArrayList<>();

	/**
	 * Generates the helpList
	 * @return ArrayList<ArrayList<String>> This is the entire list of help command and format
	 */
	public static ArrayList<ArrayList<String>> getHelpList() {
		initHelpList();
		return helpList;
	}

	private static void initHelpList() {
		for(int i = 0; i < HELP_LIST_SIZE; i++) {
			helpList.add(new ArrayList<String>());
		}

		generateHelpList();
	}

	private static void generateHelpList() {
		int index = INITIALIZE_INDEX;
		index = loadHelpCommands(index);
		index = loadHelpHotkeys(index);
	}

	private static int loadHelpCommands(int index) {
		helpList.get(++index).add(KEYBOARD_HEADING);
		helpList.get(index).add(NULL_REGEX);
		helpList.get(++index).add(HELP_ADD_DETAILS);
		helpList.get(index).add(HELP_ADD_FORMAT);
		helpList.get(++index).add(HELP_CALENDAR_DETAILS);
		helpList.get(index).add(HELP_CALENDAR_FORMAT);
		helpList.get(++index).add(HELP_CLEAR_DETAILS);
		helpList.get(index).add(HELP_CLEAR_FORMAT);
		helpList.get(++index).add(HELP_DELETE_DETAILS);
		helpList.get(index).add(HELP_DELETE_FORMAT);
		helpList.get(++index).add(HELP_DISPLAY_DETAILS);
		helpList.get(index).add(HELP_DISPLAY_FORMAT);
		helpList.get(++index).add(HELP_EDIT_DETAILS);
		helpList.get(index).add(HELP_EDIT_FORMAT);
		helpList.get(++index).add(HELP_MARK_DETAILS);
		helpList.get(index).add(HELP_MARK_FORMAT);
		helpList.get(++index).add(HELP_REDO_DETAILS);
		helpList.get(index).add(HELP_REDO_FORMAT);
		helpList.get(++index).add(HELP_SAVEAS_DETAILS);
		helpList.get(index).add(HELP_SAVEAS_FORMAT);
		helpList.get(++index).add(HELP_SEARCH_DETAILS);
		helpList.get(index).add(HELP_SEARCH_FORMAT);
		helpList.get(++index).add(HELP_TUTORIAL_DETAILS);
		helpList.get(index).add(HELP_TUTORIAL_FORMAT);
		helpList.get(++index).add(HELP_UNDO_DETAILS);
		helpList.get(index).add(HELP_UNDO_FORMAT);
		helpList.get(++index).add(HELP_UNMARK_DETAILS);
		helpList.get(index).add(HELP_UNMARK_FORMAT);
		return index;
	}
	
	private static int loadHelpHotkeys(int index) {
		helpList.get(++index).add(NULL_REGEX);
		helpList.get(index).add(NULL_REGEX);
		helpList.get(++index).add(HOTKEYS_HEADING);
		helpList.get(index).add(NULL_REGEX);
		helpList.get(++index).add(HELP_AUTOCOMPLETE_DETAILS);
		helpList.get(index).add(HELP_AUTOCOMPLETE_KEYS);
		helpList.get(++index).add(HELP_PREVIOUS_COMMAND_DETAILS);
		helpList.get(index).add(HELP_PREVIOUS_COMMAND_KEYS);
		helpList.get(++index).add(HELP_QUIT_DETAILS);
		helpList.get(index).add(HELP_QUIT_KEYS);
		helpList.get(++index).add(HELP_RECENT_COMMAND_DETAILS);
		helpList.get(index).add(HELP_RECENT_COMMAND_KEYS);
		helpList.get(++index).add(HELP_TOGGLE_COLORS_DETAILS);
		helpList.get(index).add(HELP_TOGGLE_COLORS_KEYS);
		helpList.get(++index).add(HELP_TOGGLE_INTERFACE_DETAILS);
		helpList.get(index).add(HELP_TOGGLE_INTERFACE_KEYS);
		helpList.get(++index).add(HELP_TOGGLE_TABS_DETAILS);
		helpList.get(index).add(HELP_TOGGLE_TABS_KEYS);
		return index;
	}
}
```
###### \ui\Controllers\HelpPageController.java
``` java
package ui.Controllers;

import ui.Controllers.HelpCommands.Help;
import ui.Controllers.HelpCommands.HelpCommandStorage;
import javafx.fxml.FXML;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.TableView;
import javafx.scene.control.TableColumn;
import javafx.scene.control.cell.PropertyValueFactory;

import java.util.ArrayList;

public class HelpPageController {
    
	/**
	 * This class is only called when the help page in opened
	 * It controls the help page by setting the display and properties of the help page
	 * It also retrieves the list of help commands to be displayed on the help page via sub-classes
	 * 
	 */
	
    @FXML 
    private TableView<Help> helpList;
    
    private static final String COMMAND_HEADER = "Command";
    private static final String COMMAND_FORMAT_HEADER = "Format";
    private static final String COMMAND_ID = "commandColumn";
    private static final String FORMAT_ID = "formatColumn";
    private static final String COMMAND_VALUE = "helpCommand";
    private static final String COMMAND_FORMAT_VALUE = "helpFormat";
    
    private static final int ARRAY_INDEX_COMMAND = 0;
    private static final int ARRAY_INDEX_FORMAT = 1;
    
    private static final int COMMAND_COL_WIDTH = 200;
    private static final int COMMAND_FORMAT_COL_WIDTH = 290;
    
            
    private final ObservableList<Help> table = FXCollections.observableArrayList();
    
    private ArrayList<ArrayList<String>> helpCommands = new ArrayList<>();
    
    /**
     * Constructor method
     */
    @SuppressWarnings("unchecked")
	public void initialize() {
        TableColumn<Help, String> commandCol = createColumn(COMMAND_HEADER, COMMAND_VALUE, COMMAND_COL_WIDTH);
        TableColumn<Help, String> formatCol = createColumn(COMMAND_FORMAT_HEADER, COMMAND_FORMAT_VALUE, COMMAND_FORMAT_COL_WIDTH);
        
        helpList.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        
        commandCol.setId(COMMAND_ID);
        formatCol.setId(FORMAT_ID);
        
        readFromStorage();
        helpList.setItems(table);
        helpList.getColumns().addAll(commandCol, formatCol);
    }

    /**
     * Retrieves list of help commands from a storage maintain by UI
     */
    private void readFromStorage() {
        helpCommands = HelpCommandStorage.getHelpList(); 
        for (int i = 0; i < helpCommands.size(); i++) {
            table.add(new Help(helpCommands.get(i).get(ARRAY_INDEX_COMMAND), helpCommands.get(i).get(ARRAY_INDEX_FORMAT)));
        }
        helpCommands.clear();
    }

    private TableColumn<Help, String> createColumn(String header, String value, int colWidth) {
        TableColumn<Help, String> column = new TableColumn<Help, String>(header);
        column.setMinWidth(colWidth);
        column.setCellValueFactory(new PropertyValueFactory<Help, String>(value));
        return column;
    } 
}
```
###### \ui\Controllers\ListInterfaceController.java
``` java
package ui.Controllers;

import javafx.animation.ScaleTransition;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TabPane.TabClosingPolicy;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.util.Duration;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;

import java.util.ArrayList;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Logger;

import org.controlsfx.glyphfont.FontAwesome;
import org.controlsfx.glyphfont.Glyph;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;

import ui.Controllers.MainGUIController;
import logic.Task;
import shared.LogHandler;

public class ListInterfaceController {
	
	/**
	 * 	ListInterfaceController controls the to-do list
	 * 	Primarily functions to displays the user's task list by manipulating how tasks 
	 *  a set into the list view
	 * 	It also filters the list and generate notifications by calling other classes
	 * 
	 */

	private static final int TASK_LIST_ANIMTATION_DELAY = 200;
	private static final int TASK_LIST_ANIMATION_DURATION = 400;
	private static final int REMINDER_NOTIFICATION_INTERVAL = 60000;
	private static final int GLYPH_SIZE = 20;
	private static final int TASK_START_TIME_WIDTH = 55;
	private static final int TASK_END_TIME_WIDTH = 80;
	private static final int TASK_START_DATE_WIDTH = 55;
	private static final int TASK_END_DATE_WIDTH = 55;
	private static final int TASK_NAME_WIDTH = 240;
	private static final int TASK_INDEX_WIDTH = 40;
	private static final int TASKROW_SPACING = 10;
	private static final int REMINDER_TIME = 15;
	private static final int TIME_FLAG = 1;
	private static final int DAY_FLAG = 0;
	private static final int INIT_SCROLL = 0;

	private static final String COMPLETED_TAB = "  Completed";
	private static final String PENDING_TAB = "  To-Dos";
	private static final String TODAY_TAB = "  Today";
	private static final String TOMORROW_TAB = "  Tomorrow";
	private static final String FLOAT_TAB = "  Tentative";
	private static final String OTHERS_TAB = "  Upcoming";
	private static final String OVERDUE_TAB = "  Overdue";

	private static final String INDEX_ID = "taskIndex";
	private static final String TASK_ID = "taskName";
	private static final String DATE_ID = "taskDate";
	private static final String TIME_ID = "taskTime";
	private static final String COMPLETED_TASK_ID = "completedTaskName";

	private static final String PENDING_TAB_ID = "tabPending";
	private static final String COMPLETED_TAB_ID = "tabCompleted";
	private static final String TODAY_TAB_ID = "tabToday";
	private static final String TOMORROW_TAB_ID = "tabTomorrow";
	private static final String OTHERS_TAB_ID = "tabOthers";
	private static final String FLOAT_TAB_ID = "tabFloat";
	private static final String OVERDUE_TAB_ID = "tabOverdue";

	private static final String EMPTY_LIST_FEEDBACK = "Your task list is empty.";
	private static final String EMPTY_LIST_MESSAGE = "Take a break and enjoy your day! You deserve it!";
	private static final String EMPTY_LIST_ID = "emptyRow";
	private static final String END_DATETIME_PLACEHOLDER = "to ";
	private static final String NULL = "";

	private static final String DATE_FORMAT = "dd/MM/yy";
	private static final String TIME_FORMAT = "HHmm";

	private static final String TASK_INDEX_FORMAT = "  %1s.";

	private static final boolean OPEN_LIST = true;
	private static final boolean CLOSE_LIST = false;
	private Logger log = LogHandler.retrieveLog();

	private MainGUIController main;

	@FXML private ListView<HBox> todoList;
	@FXML private HBox todoListContainer;
	@FXML private TabPane tabPane;
	@FXML private Tab tabPending = new Tab(PENDING_TAB);

	private Tab tabComplete = new Tab(COMPLETED_TAB);
	private Tab tabToday = new Tab(TODAY_TAB);
	private Tab tabTomorrow = new Tab(TOMORROW_TAB);
	private Tab tabOthers = new Tab(OTHERS_TAB);
	private Tab tabFloat = new Tab(FLOAT_TAB);
	private Tab tabOverdue = new Tab(OVERDUE_TAB);

	private static ObservableList<HBox> pendingTasks = FXCollections.observableArrayList();
	private static ObservableList<HBox> completedTasks = FXCollections.observableArrayList();
	private static ArrayList<Tab> tabs = new ArrayList<Tab>();

	private ArrayList<Task> operatingTasksFromLogic = new ArrayList<Task>();
	private ArrayList<Task> completedTasksFromLogic = new ArrayList<Task>();

	private static ObservableList<HBox> todayTasks =
			FXCollections.observableArrayList();
	private static ObservableList<HBox> tomorrowTasks =
			FXCollections.observableArrayList();
	private static ObservableList<HBox> otherTasks =
			FXCollections.observableArrayList();
	private static ObservableList<HBox> floatingTasks =
			FXCollections.observableArrayList();
	private static ObservableList<HBox> overdueTasks =
			FXCollections.observableArrayList();

	private int previousTasksSize;

	private HBox scrollSelection = new HBox();

	private TaskFilter taskFilter = new TaskFilter();
	private NotificationRenderer notification = new NotificationRenderer();
	
	/**
	 * Constructor method
	 * @param mainController The primary controller linking this and the other controllers
	 */
	public void init(MainGUIController mainController) {
		main = mainController;

		initTabPane();
		loopTaskList();
		hideToDoList();
		loopCheckTasksForReminder();
		setTaskIntoViewIndex(INIT_SCROLL);
	}

	private void initTabPane() {
		tabPane.setTabClosingPolicy(TabClosingPolicy.UNAVAILABLE);
		initTabPaneListener();
	}

	private void initTabPaneListener() {
		tabPane.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<Tab>() {
			@Override
			public void changed(ObservableValue<? extends Tab> observable, Tab oldValue, Tab newValue) {
				log.info("Tab focused: " + newValue);
				if (newValue.getContent() == null) {
					if(newValue.equals(tabPending)) {
						displayPending();
					} else if (newValue.equals(tabOverdue)) {
						displayOverdue();
					} else if (newValue.equals(tabToday)) {
						displayToday();
					} else if (newValue.equals(tabTomorrow)) {
						displayTomorrow();
					} else if (newValue.equals(tabOthers)) {
						displayOthers();
					} else if (newValue.equals(tabFloat)) {
						displayFloat();
					} else if (newValue.equals(tabComplete)) {
						displayComplete();
					}
					newValue.setContent(todoList);
					oldValue.setContent(null);
				}   
			}
		});
	}
	
	/**
	 * Initializes and maintain each tab filter
	 */
	private void operateTabs() {
		tabs.clear();
		pendingTabHandler();
		overdueTabHandler();
		todayTabHandler();
		tomorrowTabHandler();
		othersTabHandler();
		floatTabHandler();
		completedTabHandler();
		tabPane.getTabs().setAll(tabs);
	}

	private void floatTabHandler() {
		if(!tabs.contains(tabFloat) && !floatingTasks.isEmpty()) {
			tabFloat = new Tab(floatingTasks.size() + FLOAT_TAB);
			tabFloat.setId(FLOAT_TAB_ID);
			tabs.add(tabFloat);
		} else if(tabs.contains(tabFloat) && floatingTasks.isEmpty()) {
			tabs.remove(tabFloat);
		}
	}

	private void othersTabHandler() {
		if(!tabs.contains(tabOthers) && !otherTasks.isEmpty()) {
			tabOthers = new Tab(otherTasks.size() + OTHERS_TAB);
			tabOthers.setId(OTHERS_TAB_ID);
			tabs.add(tabOthers);
		} else if(tabs.contains(tabOthers) && otherTasks.isEmpty()) {
			tabs.remove(tabOthers);
		}
	}

	private void tomorrowTabHandler() {
		if(!tabs.contains(tabTomorrow) && !tomorrowTasks.isEmpty()) {
			tabTomorrow = new Tab(tomorrowTasks.size() + TOMORROW_TAB);
			tabTomorrow.setId(TOMORROW_TAB_ID);
			tabs.add(tabTomorrow);
		} else if(tabs.contains(tabTomorrow) && tomorrowTasks.isEmpty()) {
			tabs.remove(tabTomorrow);
		}
	}

	private void todayTabHandler() {
		if(!tabs.contains(tabToday) && !todayTasks.isEmpty()) {
			tabToday = new Tab(todayTasks.size() + TODAY_TAB);
			tabToday.setId(TODAY_TAB_ID);
			tabs.add(tabToday);
		} else if(tabs.contains(tabToday) && todayTasks.isEmpty()) {
			tabs.remove(tabToday);
		}
	}

	private void overdueTabHandler() {
		if(!tabs.contains(tabOverdue) && !overdueTasks.isEmpty()) {
			tabOverdue = new Tab(overdueTasks.size() + OVERDUE_TAB);
			tabOverdue.setId(OVERDUE_TAB_ID);
			tabs.add(tabOverdue);
		} else if(tabs.contains(tabOverdue) && overdueTasks.isEmpty()) {
			tabs.remove(tabOverdue);
		}
	}

	private void completedTabHandler() {
		if(!tabs.contains(tabComplete) && !completedTasksFromLogic.isEmpty()) {
			tabComplete =  new Tab(completedTasksFromLogic.size() + COMPLETED_TAB);
			tabComplete.setId(COMPLETED_TAB_ID);
			tabs.add(tabComplete);
		} else if(tabs.contains(tabComplete) && completedTasksFromLogic.isEmpty()){
			tabs.remove(tabComplete);
		}
	}

	private void pendingTabHandler() {
		tabPending =  new Tab(operatingTasksFromLogic.size() + PENDING_TAB);
		tabPending.setId(PENDING_TAB_ID);
		tabs.add(tabPending);
	}

	/**
	 * Refreshes task list and display the new task list if there are any changes
	 */
	public void loopTaskList() {
		pendingTasks.clear();
		completedTasks.clear();

		setOperatingTasksFromLogic();
		setCompletedTasksFromLogic();
		openToDoList();
		displayTasksonToDoList();
	}

	private void displayTasksonToDoList() {
		formatPendingTaskToListCell(operatingTasksFromLogic);
		formatCompletedTaskToListCell(completedTasksFromLogic);
		setTaskIntoViewObject(scrollSelection);
		operateTabs();
	}

	/**
	 * Sets tasks into view and maintains the properties for the display of each incomplete task
	 * @param taskList This is the list of task which is maintained in the storage
	 */
	private void formatPendingTaskToListCell(ArrayList<Task> taskList) {
		log.info("Pending task List is reformatted");
		
		int index = 0;
		for(Task taskObj: taskList) {
			index++;
			HBox taskRow = createTaskRow();
			Label taskIndex = createTaskIndex(index);
			Label taskName = createTaskName(taskObj, taskList);
			Label taskStartTime = createTaskStartTime(taskObj);
			Label taskEndTime = createTaskEndTime(taskObj);
			Label taskStartDate = createTaskStartDate(taskObj); 
			Label taskEndDate = createTaskEndDate(taskObj);
			setProperties(taskIndex, taskName, taskStartDate, taskEndDate, taskStartTime, taskEndTime, taskRow);
			
			if(todoListContainer.getScaleX() == 0) {
				animateToDoList(OPEN_LIST);
			}
			
			if(index == taskList.size() && taskList.size() != previousTasksSize) {
				scrollSelection = taskRow;
				previousTasksSize = operatingTasksFromLogic.size();
			} 

			if(taskFilter.isEventClashing(taskObj, taskList)) {
				Glyph glyph = new FontAwesome().create(FontAwesome.Glyph.EXCLAMATION_CIRCLE).size(GLYPH_SIZE);
				taskRow.getChildren().addAll(taskIndex, glyph, taskName, taskStartTime, taskStartDate, taskEndTime, taskEndDate);
				FeedbackGenerator.generateEventClashFeedback(main.getHelpFeedback());
			} else {
				taskRow.getChildren().addAll(taskIndex, taskName, taskStartTime, taskStartDate, taskEndTime, taskEndDate);
			}
			taskFilter.sortTasksByClasses(taskObj, taskRow);
		}	
		setTasksForCategories();
		taskFilter.addSortedClasses(pendingTasks);
		setFeedbackForEmptyList(taskList);
		todoList.setItems(pendingTasks);
	}
	
	/**
	 * Sets tasks into view and maintains the properties for the display of each completed task
	 * @param taskList This is the list of task which is maintained in the storage
	 */
	private void formatCompletedTaskToListCell(ArrayList<Task> taskList) {
		log.info("Completed task List is reformatted");
		
		int index = 0;
		for(Task taskObj: taskList) {
			index++;
			HBox taskRow = createTaskRow();
			Label taskIndex = createTaskIndex(index);
			Label taskName = createTaskName(taskObj, taskList);
			Label taskStartTime = createTaskStartTime(taskObj);
			Label taskEndTime = createTaskEndTime(taskObj);
			Label taskStartDate = createTaskStartDate(taskObj); 
			Label taskEndDate = createTaskEndDate(taskObj); 
			
			setProperties(taskIndex, taskName, taskStartDate, taskEndDate, taskStartTime, taskEndTime, taskRow);
			taskName.setId(COMPLETED_TASK_ID);
			taskRow.getChildren().addAll(taskIndex, taskName, taskStartTime, taskEndTime, taskStartDate, taskEndDate);
			completedTasks.add(taskRow);
		}
	}

	private Label createTaskStartDate(Task taskObj) {
		Label taskDate = new Label();
		if(!taskObj.get_startDate().isEmpty()) {
			taskDate = new Label(taskObj.get_startDate());
		}
		return taskDate;
	}

	private Label createTaskEndDate(Task taskObj) {
		Label taskDate = new Label();
		if(!taskObj.get_endDate().isEmpty()) {
			taskDate = new Label(taskObj.get_endDate());
		}
		return taskDate;
	}

	private Label createTaskStartTime(Task taskObj) {
		return new Label(taskObj.get_startTime());
	}

	private Label createTaskEndTime(Task taskObj) {
		Label taskTime = new Label();
		if(!taskObj.get_endTime().isEmpty()){
			taskTime = new Label(END_DATETIME_PLACEHOLDER + taskObj.get_endTime());
		}
		return taskTime;
	}

	private Label createTaskName(Task taskObj, ArrayList<Task> taskList) {
		return new Label(taskObj.get_task());
	}

	private Label createTaskIndex(int index) {
		return new Label(String.format(TASK_INDEX_FORMAT, index));
	}

	private HBox createTaskRow() {
		return new HBox(TASKROW_SPACING);
	}

	/**
	 * Loads to-do list into view
	 */
	public void openToDoList() {
		if(pendingTasks.isEmpty() && completedTasks.isEmpty() && main.getMainPane().isManaged()) {	
			todoListContainer.setManaged(true);
			todoListContainer.setOpacity(1);

			main.removeMainPane();
			animateToDoList(OPEN_LIST);
		}
	}
	
	/**
	 * Remove to-do list from view
	 */
	public void closeToDoList() {
		if(todoListContainer.getScaleX() == 1) {
			animateToDoList(CLOSE_LIST);
		}
	}

	private void hideToDoList() {
		if(pendingTasks.size() <= 1) {
			todoListContainer.setManaged(false);
			todoListContainer.setOpacity(0);
			closeToDoList();
		}
	}

	private void animateToDoList(boolean isOpen) {
		if(isOpen) {
			ScaleTransition st = new ScaleTransition(Duration.millis(TASK_LIST_ANIMATION_DURATION), todoListContainer);
			st.setFromX(0);
			st.setToX(1);
			st.setCycleCount(1);
			st.setDelay(Duration.millis(TASK_LIST_ANIMTATION_DELAY));
			st.play();
			todoListContainer.setManaged(true);
		} else {
			ScaleTransition st = new ScaleTransition(Duration.millis(TASK_LIST_ANIMATION_DURATION), todoListContainer);
			st.setFromX(1);
			st.setToX(0);
			st.setCycleCount(1);
			st.setDelay(Duration.millis(TASK_LIST_ANIMTATION_DELAY));
			st.play();
			todoListContainer.setManaged(false);
		}
	}
	
	/**
	 * Loops and check if there is any upcoming tasks every minute
	 */
	private void loopCheckTasksForReminder() {
		Timer checkTasks = new Timer(true);
		checkTasks.schedule(new TimerTask() {
			@Override
			public void run() {  
				Platform.runLater(new Runnable() {
					public void run() {
						checkTasksForReminder();
					}
				});

			}
		}, 0, REMINDER_NOTIFICATION_INTERVAL);
	}

	private void checkTasksForReminder() {
		if(!operatingTasksFromLogic.isEmpty()) {
			int todoTime = 0;
			int todoDay = 0;
			LocalDateTime localDateTime = new LocalDateTime();
			LocalDate localDate = localDateTime.toLocalDate();
			LocalTime localTime = localDateTime.toLocalTime().plusMinutes(REMINDER_TIME);
			
			for(Task taskObj: operatingTasksFromLogic) {
				if(taskObj.get_startDate().equals(localDate.toString(DATE_FORMAT)) ||
						(taskObj.get_startDate().equals(NULL) && !taskObj.get_startTime().equals(NULL))) {
					if(taskObj.get_startTime().equals(localTime.toString(TIME_FORMAT))) {
						todoTime++;
					}
					todoDay++;
				}
			}

			if(todoTime > 0) {
				log.info("Notification rendered");
				notification.loadNotification(todoTime, TIME_FLAG);
			} else if(todoDay > 0 && todoTime == 0) {
				log.info("Notification rendered");
				notification.loadNotification(todoDay, DAY_FLAG);
			}
		}
	}

	private void setCompletedTasksFromLogic() {
		completedTasksFromLogic = main.getCompletedTasksFromLogic();
	}

	private void setOperatingTasksFromLogic() {
		operatingTasksFromLogic = main.getIncompleteTasksFromLogic();
	}

	private void setTasksForCategories() {
		taskFilter.getTasksToday(todayTasks);
		taskFilter.getTasksTomorrow(tomorrowTasks);
		taskFilter.getTasksOthers(otherTasks);
		taskFilter.getTasksFloat(floatingTasks);
		taskFilter.getTasksOverdue(overdueTasks);

	}

	private void setTaskIntoViewIndex(int index) {
		if(pendingTasks.size() > 1) {
			todoList.scrollTo(index);
		}
	}

	private void setTaskIntoViewObject(HBox obj) {
		if(pendingTasks.contains(obj)) {
			todoList.scrollTo(obj);
		}
	}

	private void setFeedbackForEmptyList(ArrayList<Task> taskList) {
		if(taskList.isEmpty() ) {
			HBox emptyRow = new HBox();
			VBox rowContainer = new VBox(10);
			Label feedback = new Label(EMPTY_LIST_FEEDBACK);
			Label message = new Label(EMPTY_LIST_MESSAGE);

			emptyRow.setId(EMPTY_LIST_ID);
			rowContainer.setId(EMPTY_LIST_ID);
			rowContainer.getChildren().addAll(feedback, message);
			emptyRow.getChildren().add(rowContainer);
			pendingTasks.add(emptyRow);
		}
	}

	private void setProperties(Label index, Label name, Label date1, Label date2, Label time1, Label time2, HBox task) {
		task.setPrefWidth(600);

		HBox.setHgrow(name, Priority.ALWAYS);
		index.setPrefWidth(TASK_INDEX_WIDTH);
		index.setMaxWidth(Double.MAX_VALUE);
		index.setId(INDEX_ID);

		HBox.setHgrow(name, Priority.ALWAYS);
		name.setPrefWidth(TASK_NAME_WIDTH);
		name.setMaxWidth(Double.MAX_VALUE);
		name.setId(TASK_ID);
		name.setWrapText(true);

		HBox.setHgrow(date1, Priority.ALWAYS);
		date1.setPrefWidth(TASK_START_DATE_WIDTH);
		date1.setId(DATE_ID);

		HBox.setHgrow(date2, Priority.ALWAYS);
		date2.setPrefWidth(TASK_END_DATE_WIDTH);
		date2.setId(DATE_ID);

		HBox.setHgrow(time1, Priority.ALWAYS);
		time1.setPrefWidth(TASK_START_TIME_WIDTH);
		time1.setId(TIME_ID);

		HBox.setHgrow(time2, Priority.ALWAYS);
		time2.setPrefWidth(TASK_END_TIME_WIDTH);
		time2.setId(TIME_ID);
	}

	/**
	 * Gets tab pane 
	 * @return TabPane The tab pane containing filter tabs
	 */
	public TabPane getTabPane() {
		return tabPane;
	}

	private void displayPending() {
		main.setOperatingListAsIncomplete();
		todoList.setItems(pendingTasks);
	}

	private void displayComplete() {
		main.setOperatingListAsComplete();
		todoList.setItems(completedTasks);
	}

	private void displayToday() {
		main.setOperatingListAsIncomplete();
		todoList.setItems(todayTasks);
	}

	private void displayTomorrow() {
		main.setOperatingListAsIncomplete();
		todoList.setItems(tomorrowTasks);
	}

	private void displayOverdue() {
		main.setOperatingListAsIncomplete();
		todoList.setItems(overdueTasks);
	}

	private void displayOthers() {
		main.setOperatingListAsIncomplete();
		todoList.setItems(otherTasks);
	}

	private void displayFloat() {
		main.setOperatingListAsIncomplete();
		todoList.setItems(floatingTasks);
	}

	/**
	 * Gets the list of incomplete tasks
	 * @return ObservableList<HBox> List of incomplete task in HBox
	 */
	public ObservableList<HBox> getTasks() {
		return pendingTasks;
	}

	/**
	 * Gets the list of completed tasks
	 * @return ObservableList<HBox> List of completed Tasks in HBox
	 */
	public ObservableList<HBox> getCompleted() {
		return completedTasks;
	}
	
	/**
	 * Gets the entire list pane from todoListController
	 * @return ListView<HBox> The list view pane
	 */
	public ListView<HBox> getList() {
		return todoList;
	}
}
```
###### \ui\Controllers\MainGUIController.java
``` java
package ui.Controllers;

import java.io.IOException;
import java.util.ArrayList;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.ListView;
import javafx.scene.control.TabPane;
import javafx.scene.control.TextField;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import logic.LogicMain;
import logic.Task;

public class MainGUIController {
	
	/**
	 * The MainGUIController is the primary controller object that initializes all the other controllers
	 * All controllers can only interact with one another via this class
	 * It also acts as a facade for the both the user and logic
	 * 
	 */
	
	@FXML private CommandLineController commandLineController;  
	@FXML private ListInterfaceController todoListController;   
	@FXML private TitleInterfaceController titleController;
	@FXML private SupportFeaturesController supportFeaturesController;
	@FXML private AnchorPane backgroundPane;

	private LogicMain logic = new LogicMain();
	
	/**
	 * Constructor for MainGUIController
	 */
	public void initialize() {
		commandLineController.init(this);
		todoListController.init(this);
		titleController.init(this);
		supportFeaturesController.init(this);
	}
	
	/**
	 * Gets the background for the application
	 * @return AnchorPane background for application
	 */
	public AnchorPane getBackgroundPane() {
		return backgroundPane;
	}
	
	/**
	 * Gets main feedback from commandLineController
	 * @return Text main feedback
	 */
	public Text getMainFeedback() {
		return commandLineController.getMainFeedback();
	}
	
	/**
	 * Gets secondary feedback from commandLineController
	 * @return Text secondary feedback
	 */
	public Text getHelpFeedback() {
		return commandLineController.getHelpFeedback();
	}
	
	/**
	 * Gets tutorial flag in string from commandLineController
	 * @return String Flag for indication of whether tutorial is ON or OFF
	 */
	public String getTutorialMode() {
		return commandLineController.getTutorialToggle();
	}
	
	/**
	 * Gets user input field from commandLineController
	 * @return TextField This is the user input field
	 */
	public TextField getCommandLine() {
		return commandLineController.getCommandLine();
	}
	
	/**
	 * Refreshes the to-do list
	 */
	public void refreshToDoList() {
		todoListController.loopTaskList();
	}
	
	/**
	 * Remove to-do list from view
	 */
	public void removeToDoList() {
		todoListController.closeToDoList();
	}
	
	/**
	 * Loads to-do list into view
	 */
	public void openToDoList() {
		todoListController.openToDoList();
	}
	
	/**
	 * Gets the list of incomplete tasks from todoListController
	 * @return ObservableList<HBox> List of incomplete task in HBox
	 */
	public ObservableList<HBox> getTaskList() {
		return todoListController.getTasks();
	}
	
	/**
	 * Gets the list of completed tasks from todoListController
	 * @return ObservableList<HBox> List of completed Tasks in HBox
	 */
	public ObservableList<HBox> getCompletedList() {
		return todoListController.getCompleted();
	}
	
	/**
	 * Gets tab pane from todoListController
	 * @return TabPane The tab pane containing filter tabs
	 */
	public TabPane getTabPane() {
		return todoListController.getTabPane();
	}
	
	/**
	 * Gets the entire list pane from todoListController
	 * @return ListView<HBox> The list view pane
	 */
	public ListView<HBox> getList() {
		return todoListController.getList();
	}

	/**
	 * Gets the center pane that holds supporting features
	 * from supportFeaturesController
	 * @return VBox This is the center pane for several features
	 */
	public VBox getMainPane() {
		return supportFeaturesController.getMainPane();
	}
	
	/**
	 * Loads the center pane into view
	 */
	public void openMainPane() {
		supportFeaturesController.showMainPane();
	}
	
	/**
	 * Removes the center main from view
	 */
	public void removeMainPane() {
		supportFeaturesController.removeMainPane();
	}
	
	/**
	 * Starts tutorial
	 * @throws IOException If an I/O Error occurs
	 */
	public void startTutorialMode() {
		supportFeaturesController.renderTutorial();
	}
	
	/**
	 * Displays help page
	 */
	public void renderHelpPage() {
		supportFeaturesController.loadHelpList();
	}
	
	/**
	 * Displays calendar
	 */
	public void renderCalendar() {
		supportFeaturesController.loadCalendar();
	}
	
	/**
	 * Gets an instance of Logic
	 * @return LogicMain This is an instance of LogicMain object
	 */
	public LogicMain getLogic() {
		return logic;
	}
	
	/**
	 * Passes the user input to Logic
	 * @param input This is the user input
	 * @return String This is the feedback from Logic
	 */
	public String passInputToLogic(String input) {
		assert (this != null);
		return logic.processCommand(input);
	}
	
	/**
	 * Gets list of incomplete tasks from Logic
	 * @return ArrayList<Task> List of incomplete TaskObjects
	 */
	public ArrayList<Task> getIncompleteTasksFromLogic() {
		return logic.getOperatingTasksForUI();
	}
	
	/**
	 * Gets list of completed tasks from Logic
	 * @return ArrayList<Task> List of completed TaskObjects
	 */
	public ArrayList<Task> getCompletedTasksFromLogic() {
		return logic.getCompleteTasksForUI();
	}
	
	/**
	 * Sets operating list to display complete tasks
	 */
	public void setOperatingListAsComplete() {
		logic.operatingToComplete();
	}
	
	/**
	 * Sets operating list to display incomplete tasks
	 */
	public void setOperatingListAsIncomplete() {
		logic.operatingToIncomplete();
	}
}
```
###### \ui\Controllers\NotificationRenderer.java
``` java
package ui.Controllers;

import javafx.geometry.Pos;
import javafx.util.Duration;

import org.controlsfx.control.Notifications;

public class NotificationRenderer {
	
	/**
	 * This class set the properties of the notification and display it to users
	 * It retrieves the number of incoming task and displays a reminder note
	 * The notification is rendered for tasks with deadlines 15 minutes prior or daily tasks when
	 * the application is loaded
	 * 
	 */

	private static final String REMINDER_HEADING = "Reminder!\n";
	private static final String REMINDER_NOTIFICATION_TIME_PLURAL = "\nYou have %1s pending tasks in 15 minutes!";
	private static final String REMINDER_NOTIFICATION_TIME_SINGULAR = "\nYou have %1s pending task in 15 minutes!";
	private static final String REMINDER_NOTIFICATION_DAY_PLURAL = "\nYou have %1s pending tasks in 15 minutes!";
	private static final String REMINDER_NOTIFICATION_DAY_SINGULAR = "\nYou have %1s pending task in 15 minutes!";
	
	private static final int TIME_FLAG = 1;
	private static final int DAY_FLAG = 0;
	private static final int NOTIFICATION_DURATION = 3;
	
	private boolean dayNotification;
	private boolean timeNotification;
	
	/**
	 * Constructor method
	 */
	public NotificationRenderer() {
		dayNotification = false;
		timeNotification = false;
	}

	/**
	 * Loads notification into view
	 * @param todo This is the number of upcoming to-dos
	 * @param flag This is the indication of whether it is a daily or time reminder
	 */
	public void loadNotification(int todo, int flag) {
		if(flag == TIME_FLAG && timeNotification == false) {
			if(todo > 1) {
				showNotificationTimePlural(todo);
			} else if (todo == 1) {
				showNotificationTimeSingular(todo);
			}
		} else if(flag == DAY_FLAG && dayNotification == false) {
			if(todo > 1) {
				showNotificationDayPlural(todo);
			} else if (todo == 1){
				showNotificationDaySingular(todo);
			}
			dayNotification = true;
		}
	}

	private void showNotificationTimePlural(int todo) {
		Notifications.create()
		.title(REMINDER_HEADING)
		.text(String.format(REMINDER_NOTIFICATION_TIME_PLURAL, todo))
		.position(Pos.TOP_RIGHT)
		.hideAfter(Duration.seconds(NOTIFICATION_DURATION))
		.showWarning();
	}

	private void showNotificationTimeSingular(int todo) {
		Notifications.create()
		.title(REMINDER_HEADING)
		.text(String.format(REMINDER_NOTIFICATION_TIME_SINGULAR, todo))
		.position(Pos.TOP_RIGHT)
		.hideAfter(Duration.seconds(NOTIFICATION_DURATION))
		.showWarning();
	}

	private void showNotificationDayPlural(int todo) {
		Notifications.create()
		.title(REMINDER_HEADING)
		.text(String.format(REMINDER_NOTIFICATION_DAY_PLURAL, todo))
		.position(Pos.TOP_RIGHT)
		.hideAfter(Duration.seconds(NOTIFICATION_DURATION))
		.showWarning();
	}

	private void showNotificationDaySingular(int todo) {
		Notifications.create()
		.title(REMINDER_HEADING)
		.text(String.format(REMINDER_NOTIFICATION_DAY_SINGULAR, todo))
		.position(Pos.TOP_RIGHT)
		.hideAfter(Duration.seconds(NOTIFICATION_DURATION))
		.showWarning();
	}
}
```
###### \ui\Controllers\SupportFeaturesController.java
``` java
package ui.Controllers;

import java.io.IOException;
import java.time.LocalDate;
import java.util.Timer;
import java.util.TimerTask;

import org.joda.time.LocalTime;

import com.sun.javafx.scene.control.skin.DatePickerSkin;
import javafx.animation.FadeTransition;
import javafx.application.Platform;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.control.DatePicker;
import javafx.scene.control.Label;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.util.Duration;

@SuppressWarnings("restriction")
public class SupportFeaturesController {
	
	/**
	 * The SupportFeaturesController controls a hidden center pane that will display various supporting
	 * features for the application
	 * Features included are calendar, help page, tutorial and the main title
	 * It sets the properties for all the features and renders them
	 * 
	 */
	
	private static final int TIME_CHECK_INTERVAL = 1000;
	private static final int CALENDAR_SPACING = 10;
	private static final int HEADING_SIZE = 20;
	private static final int IMAGE_SIZE = 40;
	private static final int MAIN_PANE_ANIMATION_DURATION = 200;
	
	private static final String HELP_PAGE_PATH = "/ui/View/HelpPage.fxml";
	private static final String ICON_PATH = "/ui/Application/Stylesheets/Background/time-icon.png";
	private static final String CALENDAR_HEADING = "   SCHEDULE";
	private static final String CALENDAR_ID = "calendarContainer";
	private static final String TIME_ID = "calendarTime";
	private static final String TIME_FORMAT = "HH:mm:ss";
	private static final int TIME_LABEL_INDEX = 1;
	
	private static final String TUTORIAL_NOTIFICATION = "Tutorial Mode: %1s, SHIFT+RIGHT to toggle";
	
	private MainGUIController main;
	private TutorialRenderer tutorialRenderer;
	private Node calendar;
	private Label heading;
	private Label time;

	@FXML private Text titleMessage;
	@FXML private Text subMessage;
	@FXML private VBox mainPane;

	/**
	 * Constructor method
	 * @param mainController The primary controller linking this and the other controllers
	 */
	public void init(MainGUIController mainController) {
		main = mainController;
		tutorialRenderer = new TutorialRenderer(main);
		
		if(main.getTaskList().size() <= 1) {
			showMainPane();
		}
	}

	/**
	 * Gets the center pane that holds supporting features
	 * from supportFeaturesController
	 * @return VBox This is the center pane for several features
	 */
	public VBox getMainPane() {
		return mainPane;
	}
	
	/**
	 * Starts tutorial and display it
	 * @throws IOException If an I/O Error occurs
	 */
	public void renderTutorial() {
		tutorialRenderer.loadTutorial();
	}
	
	/**
	 * Displays help page
	 * @throws IOException If an I/O Error occurs
	 */
	public void loadHelpList() {
		main.removeToDoList();
		showMainPane();
		mainPane.getChildren().clear();
		try {
			mainPane.getChildren().add(FXMLLoader.load(getClass().getResource(HELP_PAGE_PATH)));
		} catch (IOException e)  {
			e.printStackTrace();
		}
	}
	
	/**
	 * Displays calendar
	 * @throws IOException If an I/O Error occurs
	 */
	public void loadCalendar() {
		VBox calendarContainer = new VBox(CALENDAR_SPACING);

		main.removeToDoList();
		setCalendarProperties(calendarContainer);
		showMainPane();
		insertCalendarIntoContainer(calendarContainer);
	}

	private void insertCalendarIntoContainer(VBox calendarContainer) {
		mainPane.getChildren().clear();
		mainPane.getChildren().add(calendarContainer);
	}

	private void setCalendarProperties(VBox calendarContainer) {
		calendar = new DatePickerSkin(new DatePicker(LocalDate.now())).getPopupContent();
		loopCheckTime(calendarContainer);
	}
	
	/**
	 * Checks and changes the time every second to create a functioning clock
	 * @param calendarContainer This is the pane containing the entire calendar
	 */
	private void loopCheckTime(VBox calendarContainer) {
		Timer checkTasks = new Timer(true);
		checkTasks.schedule(new TimerTask() {
			@Override
			public void run() {  
				Platform.runLater(new Runnable() {
					public void run() {
						setCalendarIntoPlace(calendarContainer);
					}
				});

			}
		}, 0, TIME_CHECK_INTERVAL);
	}

	private String setTimeProperties() {
		return new LocalTime().toString(TIME_FORMAT);
	}

	private Label setHeadingProperties(ImageView imageView) {
		Label label = new Label(CALENDAR_HEADING);
		label.setTextFill(Color.BLACK);
		label.setGraphic(imageView);
		label.setFont(Font.font(HEADING_SIZE));
		return label;
	}

	private ImageView setImageViewProperties() {
		Image image = new Image(getClass().getResourceAsStream(ICON_PATH));
		ImageView imageView = new ImageView(image);
		imageView.setFitHeight(IMAGE_SIZE);
		imageView.setFitWidth(IMAGE_SIZE);
		imageView.setPreserveRatio(true);
		return imageView;
	}

	/**
	 * Removes the center main from view
	 */
	public void removeMainPane() {
		mainPane.setManaged(false);

		FadeTransition ft = new FadeTransition(Duration.millis(MAIN_PANE_ANIMATION_DURATION), mainPane);
		ft.setFromValue(1);
		ft.setToValue(0);
		ft.play();
	}

	/**
	 * Loads the center pane into view
	 */
	public void showMainPane() {
		mainPane.setManaged(true);
		insertTutorialToggle();

		FadeTransition ft = new FadeTransition(Duration.millis(MAIN_PANE_ANIMATION_DURATION), mainPane);
		ft.setFromValue(0);
		ft.setToValue(1);
		ft.play();
	}
	
	private void insertTutorialToggle() {
		Text tutorialLabel = new Text(String.format(TUTORIAL_NOTIFICATION, main.getTutorialMode()));
		if(mainPane.getChildren().size() > 3) {
			mainPane.getChildren().set(mainPane.getChildren().size()-1, tutorialLabel);
		} else {
			mainPane.getChildren().add(tutorialLabel);
		}
	}

	private void setCalendarIntoPlace(VBox calendarContainer) {
		ImageView imageView = setImageViewProperties();
		heading = setHeadingProperties(imageView);
		time = new Label(setTimeProperties());
		time.setId(TIME_ID);
		calendarContainer.setId(CALENDAR_ID);
		if(calendarContainer.getChildren().isEmpty()) {
			calendarContainer.getChildren().addAll(heading, time, calendar);
		} else {
			calendarContainer.getChildren().set(TIME_LABEL_INDEX, time);
		}
	}

}
```
###### \ui\Controllers\TaskFilter.java
``` java
package ui.Controllers;

import java.util.ArrayList;

import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import org.joda.time.format.DateTimeFormat;

import javafx.collections.ObservableList;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import logic.Task;

public class TaskFilter {
	
	/**
	 * This class functions to filter/sort tasks by time and adds them into a task list
	 * 
	 */
	
	private static final String NULL_FLAG = "";
	private static final String FILTER_PLACEHOLDER = " : ";
	private static final String DATE_FORMAT = "dd/MM/yy";
	private static final String TIME_FORMAT = "h.mma";

	private static final String FLOAT_ID = "classFloat";
	private static final String OTHERS_ID = "classOthers";
	private static final String TOMORROW_ID = "classTomorrow";
	private static final String TODAY_ID = "classToday";
	private static final String OVERDUE_ID = "classOverdue";
	private static final String NUM_ID = "numTask";

	private static final String FLOAT_TASK_ID = "taskFloat";
	private static final String OTHERS_TASK_ID = "taskOthers";
	private static final String TOMORROW_TASK_ID = "taskTomorrow";
	private static final String TODAY_TASK_ID = "taskToday";
	private static final String OVERDUE_TASK_ID = "taskOverdue";

	private static final int CLASS_SPACE = 20;

	private static final String TODAY_CLASS = "Today";
	private static final String TOMORROW_CLASS = "Tomorrow";
	private static final String FLOAT_CLASS = "Tentative";
	private static final String OTHERS_CLASS = "Upcoming";
	private static final String OVERDUE_CLASS = "Overdue";

	private ArrayList<HBox> tasksToday;
	private ArrayList<HBox> tasksTomorrow;
	private ArrayList<HBox> tasksOthers;
	private ArrayList<HBox> tasksFloat;
	private ArrayList<HBox> tasksOverdue;

	private HBox taskClassToday;
	private HBox taskClassTomorrow;
	private HBox taskClassOthers;
	private HBox taskClassFloat;
	private HBox taskClassOverdue;


	/**
	 * Constructor method
	 */
	public TaskFilter() {
		tasksToday = new ArrayList<HBox>();
		tasksTomorrow = new ArrayList<HBox>();
		tasksOthers= new ArrayList<HBox>();
		tasksFloat = new ArrayList<HBox>();
		tasksOverdue = new ArrayList<HBox>();

		initClasses();
	}
	
	/**
	 * Gets list of tasks today
	 * @param list List of tasks today in HBox
	 */
	public void getTasksToday(ObservableList<HBox> list) {
		list.clear();
		for(int i = 1; i < tasksToday.size(); i++) {
			list.add(tasksToday.get(i));
		}
	}
	
	/**
	 * Gets list of tasks today
	 * @param list List of tasks tomorrow in HBox
	 */
	public void getTasksTomorrow(ObservableList<HBox> list) {
		list.clear();
		for(int i = 1; i < tasksTomorrow.size(); i++) {
			list.add(tasksTomorrow.get(i));
		}
	}
	
	/**
	 * Gets list of tasks today
	 * @param list List of other tasks in HBox
	 */
	public void getTasksOthers(ObservableList<HBox> list) {
		list.clear();
		for(int i = 1; i < tasksOthers.size(); i++) {
			list.add(tasksOthers.get(i));
		}
	}

	/**
	 * Gets list of tasks today
	 * @param list List of overdue tasks in HBox
	 */
	public void getTasksOverdue(ObservableList<HBox> list) {
		list.clear();
		for(int i = 1; i < tasksOverdue.size(); i++) {
			list.add(tasksOverdue.get(i));
		}
	}

	/**
	 * Gets list of tasks today
	 * @param list List of floating tasks in HBox
	 */
	public void getTasksFloat(ObservableList<HBox> list) {
		list.clear();
		for(int i = 1; i < tasksFloat.size(); i++) {
			list.add(tasksFloat.get(i));
		}
	}

	private void initClasses() {
		taskClassToday = new HBox(CLASS_SPACE);
		Label taskToday = new Label(TODAY_CLASS);
		taskToday.setId(TODAY_ID);
		taskClassToday.getChildren().add(taskToday);

		taskClassTomorrow = new HBox(CLASS_SPACE);
		Label taskTomorrow = new Label(TOMORROW_CLASS);
		taskTomorrow.setId(TOMORROW_ID);
		taskClassTomorrow.getChildren().add(taskTomorrow);

		taskClassOthers = new HBox(CLASS_SPACE);
		Label taskOthers = new Label(OTHERS_CLASS);
		taskOthers.setId(OTHERS_ID);
		taskClassOthers.getChildren().add(taskOthers);

		taskClassFloat = new HBox(CLASS_SPACE);
		Label taskFloat = new Label(FLOAT_CLASS);
		taskFloat.setId(FLOAT_ID);
		taskClassFloat.getChildren().add(taskFloat);

		taskClassOverdue = new HBox(CLASS_SPACE);
		Label taskOverdue = new Label(OVERDUE_CLASS);
		taskOverdue.setId(OVERDUE_ID);
		taskClassOverdue.getChildren().add(taskOverdue);
	}

	private void clearAll() {
		tasksToday.clear();
		tasksTomorrow.clear();
		tasksOthers.clear();
		tasksFloat.clear();
		tasksOverdue.clear();
	}
	
	/**
	 * Add the filtered classes into the main list
	 * @param list This is the list of tasks from ListInterface
	 */
	public void addSortedClasses(ObservableList<HBox> list) {
		int taskNum = 1;
		while(taskNum <= tasksToday.size() + tasksTomorrow.size() +
				tasksFloat.size() + tasksOthers.size() + tasksOverdue.size()) {

			final int overdueSize = tasksOverdue.size();
			final int overdueTodaySize = tasksOverdue.size() + tasksToday.size();
			final int overdueTodayTomorrowSize = tasksOverdue.size() + tasksToday.size() + tasksTomorrow.size();
			final int overdueTodayTomorrowOthersSize = tasksOverdue.size() + tasksToday.size() + tasksTomorrow.size() + tasksOthers.size();

			if(taskNum <= overdueSize) {
				addOverdueToList(list, taskNum);	
			} else if(taskNum >= overdueSize && taskNum <= overdueTodaySize) {
				addTodayToList(list, taskNum);
			} else if(taskNum >= overdueTodaySize && taskNum <= overdueTodayTomorrowSize) {
				addTomorrowToList(list, taskNum);
			} else if(taskNum >= overdueTodayTomorrowSize && taskNum <= overdueTodayTomorrowOthersSize) {
				addOthersToList(list, taskNum);
			} else if(taskNum >= overdueTodayTomorrowOthersSize) {
				addFloatToList(list, taskNum);
			} 
			taskNum++;
		}
		clearAll();
	}

	private void addFloatToList(ObservableList<HBox> list, int taskNum) {
		final int overdueTodayTomorrowOthersSize = tasksOverdue.size() + tasksToday.size() + tasksTomorrow.size() + tasksOthers.size();

		if(taskNum == overdueTodayTomorrowOthersSize + 1) {
			updateFloatCount(taskNum);
		}
		list.add(tasksFloat.get(taskNum-overdueTodayTomorrowOthersSize-1));
	}

	private void addOthersToList(ObservableList<HBox> list, int taskNum) {
		final int overdueTodayTomorrowSize = tasksOverdue.size() + tasksToday.size() + tasksTomorrow.size();

		if(taskNum == overdueTodayTomorrowSize + 1) {
			updateOthersCount(taskNum);
		}
		list.add(tasksOthers.get(taskNum- overdueTodayTomorrowSize-1));
	}

	private void addTomorrowToList(ObservableList<HBox> list, int taskNum) {
		final int overdueTodaySize = tasksOverdue.size() + tasksToday.size();

		if(taskNum == overdueTodaySize + 1) {
			updateTomorrowCount(taskNum);
		}
		list.add(tasksTomorrow.get(taskNum-overdueTodaySize-1));
	}

	private void addTodayToList(ObservableList<HBox> list, int taskNum) {
		final int overdueSize = tasksOverdue.size();

		if(taskNum == overdueSize + 1) {
			updateTodayCount(taskNum);
		}
		list.add(tasksToday.get(taskNum-overdueSize-1));
	}

	private void addOverdueToList(ObservableList<HBox> list, int taskNum) {
		if(taskNum == 1) {
			updateOverdueCount(taskNum);
		}
		list.add(tasksOverdue.get(taskNum-1));
	}

	private void updateFloatCount(int taskNum) {
		final int overdueTodayTomorrowOthersSize = tasksOverdue.size() + tasksToday.size() + tasksTomorrow.size() + tasksOthers.size();

		Label taskFloatNum = new Label(FILTER_PLACEHOLDER + (tasksFloat.size()-1));
		taskFloatNum.setId(NUM_ID);

		if(tasksFloat.get(taskNum-overdueTodayTomorrowOthersSize-1).getChildren().size() == 2) {
			tasksFloat.get(taskNum-overdueTodayTomorrowOthersSize-1).getChildren().set(1, taskFloatNum);
		} else {
			tasksFloat.get(taskNum-overdueTodayTomorrowOthersSize-1).getChildren().add(taskFloatNum);
		}
	}

	/*
	 * update count of respective category
	 */

	private void updateOthersCount(int taskNum) {
		final int overdueTodayTomorrowSize = tasksOverdue.size() + tasksToday.size() + tasksTomorrow.size();

		Label taskOthersNum = new Label(FILTER_PLACEHOLDER + (tasksOthers.size()-1));
		taskOthersNum.setId(NUM_ID);

		if(tasksOthers.get(taskNum-overdueTodayTomorrowSize-1).getChildren().size() == 2) {
			tasksOthers.get(taskNum-overdueTodayTomorrowSize-1).getChildren().set(1, taskOthersNum);
		} else {
			tasksOthers.get(taskNum-overdueTodayTomorrowSize-1).getChildren().add(taskOthersNum);
		}
	}

	private void updateTomorrowCount(int taskNum) {
		final int overdueTodaySize = tasksOverdue.size() + tasksToday.size();

		Label taskTomorrowNum = new Label(FILTER_PLACEHOLDER + (tasksTomorrow.size()-1));
		taskTomorrowNum.setId(NUM_ID);
		if(tasksTomorrow.get(taskNum-overdueTodaySize-1).getChildren().size() == 2) {
			tasksTomorrow.get(taskNum-overdueTodaySize-1).getChildren().set(1, taskTomorrowNum);
		} else {
			tasksTomorrow.get(taskNum-overdueTodaySize-1).getChildren().add(taskTomorrowNum);
		}
	}

	private void updateTodayCount(int taskNum) {
		final int overdueSize = tasksOverdue.size();

		Label taskTodayNum = new Label(FILTER_PLACEHOLDER + (tasksToday.size()-1));
		taskTodayNum.setId(NUM_ID);
		if(tasksToday.get(taskNum-overdueSize-1).getChildren().size() == 2) {
			tasksToday.get(taskNum-overdueSize-1).getChildren().set(1, taskTodayNum);
		} else {
			tasksToday.get(taskNum-overdueSize-1).getChildren().add(taskTodayNum);
		}
	}

	private void updateOverdueCount(int taskNum) {
		Label taskOverdueNum = new Label(FILTER_PLACEHOLDER + (tasksOverdue.size()-1));
		taskOverdueNum.setId(NUM_ID);
		if(tasksOverdue.get(taskNum-1).getChildren().size() == 2) {
			tasksOverdue.get(taskNum-1).getChildren().set(1, taskOverdueNum);
		} else {
			tasksOverdue.get(taskNum-1).getChildren().add(taskOverdueNum);
		}
	}
	
	/**
	 * Sorts tasks by filtering them according to time and date
	 * @param taskObj This is individual task object from the task list in ListInterface
	 * @param taskRow This is individual rows of tasks in the ListView
	 */
	public void sortTasksByClasses(Task taskObj, HBox taskRow) {
		LocalDateTime localDate = new LocalDateTime();
		String dateToday = localDate.toString(DATE_FORMAT);
		String dateTomorrow = localDate.plusDays(1).toString(DATE_FORMAT);

		LocalDateTime taskDate = new LocalDateTime();
		LocalTime taskTime = new LocalTime();
		LocalTime timeNow = new LocalTime();

		if(taskObj.get_startDate() != NULL_FLAG) {
			taskDate = LocalDateTime.parse(taskObj.get_startDate(), DateTimeFormat.forPattern(DATE_FORMAT));
			if(taskObj.get_startTime() != NULL_FLAG) {
				taskTime = LocalDateTime.parse(taskObj.get_startTime(), DateTimeFormat.forPattern(TIME_FORMAT)).toLocalTime();
			}
		}

		if(taskDate.plusDays(1).isBefore(localDate) 
				|| (taskObj.get_startDate().equals(dateToday) && taskTime.isBefore(timeNow))) {
			checkAndAddClassOverdue(taskRow);
		} else if(taskObj.get_startDate().equals(dateToday) 
				|| (!taskObj.get_startTime().isEmpty() && taskObj.get_startDate().isEmpty())) {
			checkAndAddClassToday(taskRow);
		} else if(taskObj.get_startDate().equals(dateTomorrow)) {
			checkAndAddTomorrow(taskRow);
		} else if(taskObj.get_startTime().isEmpty() && taskObj.get_startDate().isEmpty()) {
			checkAndAddClassFloat(taskRow);
		} else {
			checkAndAddClassOthers(taskRow);
		}
	}

	private void checkAndAddClassOthers(HBox taskRow) {
		if(!tasksOthers.contains(taskClassOthers)) {
			tasksOthers.add(taskClassOthers);
		}
		taskRow.setId(OTHERS_TASK_ID);
		tasksOthers.add(taskRow);
	}

	private void checkAndAddClassFloat(HBox taskRow) {
		if(!tasksFloat.contains(taskClassFloat)) {
			tasksFloat.add(taskClassFloat);
		}
		taskRow.setId(FLOAT_TASK_ID);
		tasksFloat.add(taskRow);
	}

	private void checkAndAddTomorrow(HBox taskRow) {
		if(!tasksTomorrow.contains(taskClassTomorrow)) {
			tasksTomorrow.add(taskClassTomorrow);
		}
		taskRow.setId(TOMORROW_TASK_ID);
		tasksTomorrow.add(taskRow);
	}

	private void checkAndAddClassToday(HBox taskRow) {
		if(!tasksToday.contains(taskClassToday)) {
			tasksToday.add(taskClassToday);	
		}
		taskRow.setId(TODAY_TASK_ID);
		tasksToday.add(taskRow);
	}


	private void checkAndAddClassOverdue(HBox taskRow) {
		if(!tasksOverdue.contains(taskClassOverdue)) {
			tasksOverdue.add(taskClassOverdue);
		}
		taskRow.setId(OVERDUE_TASK_ID);
		tasksOverdue.add(taskRow);
	}

	/**
	 * Check tasks individually for clashes by comparing them with another task in the task list
	 * @param taskObj This is individual task object from the task list in ListInterface
	 * @param taskList This is the entire list of tasks from ListInterface
	 * @return true if there are tasks with clashing event, false if there are no clashes
	 */
	public boolean isEventClashing(Task taskObj, ArrayList<Task> taskList) {
		LocalDateTime taskObjStartDate = new LocalDateTime();
		LocalTime taskObjStartTime = new LocalTime();
		LocalDateTime taskObjEndDate = new LocalDateTime();
		LocalTime taskObjEndTime = new LocalTime();

		LocalDateTime taskComparedStartDate = new LocalDateTime();
		LocalTime taskComparedStartTime = new LocalTime();
		LocalDateTime taskComparedEndDate = new LocalDateTime();
		LocalTime taskComparedEndTime = new LocalTime();

		if(isTaskValidEvent(taskObj)) {
			taskObjStartDate = LocalDateTime.parse(taskObj.get_startDate(), DateTimeFormat.forPattern(DATE_FORMAT));
			taskObjEndDate = LocalDateTime.parse(taskObj.get_endDate(), DateTimeFormat.forPattern(DATE_FORMAT));
			taskObjStartTime = LocalDateTime.parse(taskObj.get_startTime(), DateTimeFormat.forPattern(TIME_FORMAT)).toLocalTime();
			taskObjEndTime = LocalDateTime.parse(taskObj.get_endTime(), DateTimeFormat.forPattern(TIME_FORMAT)).toLocalTime();
		} else {
			return false;
		}

		for(Task task: taskList) {
			if(task.isEqualTask(taskObj)) {
				continue;
			}
			if(isTaskValidEvent(task)) {
				taskComparedStartDate = LocalDateTime.parse(task.get_startDate(), DateTimeFormat.forPattern(DATE_FORMAT));
				taskComparedEndDate = LocalDateTime.parse(task.get_endDate(), DateTimeFormat.forPattern(DATE_FORMAT));
				taskComparedStartTime = LocalDateTime.parse(task.get_startTime(), DateTimeFormat.forPattern(TIME_FORMAT)).toLocalTime();
				taskComparedEndTime = LocalDateTime.parse(task.get_endTime(), DateTimeFormat.forPattern(TIME_FORMAT)).toLocalTime();

				if(isSelectedTaskEndDateClashingWithStartDate(taskObjEndDate, taskComparedStartDate, taskComparedEndDate)) {
					if(isSelectedTaskTimeClashingForEndClashWithStart(taskObjEndTime, taskComparedStartTime, taskComparedEndTime)) {
						return true;
					} 

				} else if(isSelectedTaskStartDateClashingWithStartDate(taskObjStartDate, taskComparedStartDate, taskComparedEndDate)) {
					if(taskObjStartDate.isEqual(taskComparedEndDate)) {
						if(isSelectedTaskTimeClashingForStartClashWithEnd(taskObjStartTime, taskComparedStartTime, taskComparedEndTime)) {
							return true;
						} else {
							return false;
						}
					}
					return true;

				} else if(isSelectedTaskEndDateBetweenStartAndEndDate(taskObjEndDate, taskComparedStartDate, taskComparedEndDate)
						|| isSelectedTaskStartDateBetweenStartAndEndDate(taskObjStartDate, taskComparedStartDate, taskComparedEndDate)) {
					return true;

				}  else if(isSelectedTaskDatesCoverStartAndEndDate(taskObjStartDate, taskObjEndDate, 
						taskComparedStartDate, taskComparedEndDate)) {
					return true;

				} else if(isSelectedTaskEndDateClashingWithEndDate(taskObjEndDate, taskComparedStartDate, taskComparedEndDate)) {
					if(taskObjStartDate.isEqual(taskComparedEndDate)) {
						if(isSelectedTaskTimeClashingForStartClashWithEnd(taskObjStartTime, taskComparedStartTime, taskComparedEndTime)) {
							return true;
						} else {
							return false;
						}
					}
					return true;

				} else if(isSelectedTaskStartDateClashingWithEndDate(taskObjStartDate, taskComparedStartDate, taskComparedEndDate)) {
					if(isSelectedTaskTimeClashingForStartClashWithEnd(taskObjStartTime, taskComparedStartTime, taskComparedEndTime)) {
						return true;
					} 
				}
			}
		}

		return false;
	}

	private boolean isTaskValidEvent(Task task) {
		return task.get_startDate() != NULL_FLAG && task.get_endDate() != NULL_FLAG 
				&& task.get_startTime() != NULL_FLAG && task.get_endTime() != NULL_FLAG;
	}

	private boolean isSelectedTaskEndDateClashingWithStartDate(LocalDateTime taskObjEndDate, LocalDateTime taskComparedStartDate,
			LocalDateTime taskComparedEndDate) {
		return (taskObjEndDate.isEqual(taskComparedStartDate));
	}

	private boolean isSelectedTaskEndDateBetweenStartAndEndDate(LocalDateTime taskObjEndDate, LocalDateTime taskComparedStartDate,
			LocalDateTime taskComparedEndDate) {
		return (taskObjEndDate.isAfter(taskComparedStartDate) 
				&& taskObjEndDate.isBefore(taskComparedEndDate) );
	}

	private boolean isSelectedTaskEndDateClashingWithEndDate(LocalDateTime taskObjEndDate, LocalDateTime taskComparedStartDate,
			LocalDateTime taskComparedEndDate) {
		return (taskObjEndDate.isEqual(taskComparedEndDate));
	}

	private boolean isSelectedTaskStartDateClashingWithStartDate(LocalDateTime taskObjStartDate, LocalDateTime taskComparedStartDate,
			LocalDateTime taskComparedEndDate) {
		return (taskObjStartDate.isEqual(taskComparedStartDate));
	}

	private boolean isSelectedTaskStartDateBetweenStartAndEndDate(LocalDateTime taskObjStartDate, LocalDateTime taskComparedStartDate,
			LocalDateTime taskComparedEndDate) {
		return (taskObjStartDate.isAfter(taskComparedStartDate) 
				&& taskObjStartDate.isBefore(taskComparedEndDate) );
	}

	private boolean isSelectedTaskStartDateClashingWithEndDate(LocalDateTime taskObjStartDate, LocalDateTime taskComparedStartDate,
			LocalDateTime taskComparedEndDate) {
		return (taskObjStartDate.isEqual(taskComparedEndDate));
	}

	private boolean isSelectedTaskDatesCoverStartAndEndDate(LocalDateTime taskObjStartDate, LocalDateTime taskObjEndDate, 
			LocalDateTime taskComparedStartDate, LocalDateTime taskComparedEndDate) {
		return (taskObjStartDate.isBefore(taskComparedStartDate) 
				&& taskObjEndDate.isAfter(taskComparedEndDate) );
	}

	private boolean isSelectedTaskTimeClashingForEndClashWithStart(LocalTime taskObjEndTime, LocalTime taskComparedStartTime,
			LocalTime taskComparedEndTime) {
		return (taskObjEndTime.isAfter(taskComparedStartTime));
	}

	private boolean isSelectedTaskTimeClashingForStartClashWithEnd(LocalTime taskObjStartTime, LocalTime taskComparedStartTime,
			LocalTime taskComparedEndTime) {
		return (taskObjStartTime.isBefore(taskComparedEndTime));
	}
}
```
###### \ui\Controllers\TitleInterfaceController.java
``` java
package ui.Controllers;

import javafx.scene.text.Text;
import javafx.util.Duration;
import javafx.animation.FadeTransition;
import javafx.fxml.FXML;
import java.util.Timer;
import java.util.TimerTask;
import ui.Controllers.MainGUIController;
import ui.Controllers.TitleQuotes.QuoteGenerator;

public class TitleInterfaceController extends QuoteGenerator{
	
	/**
	 * TitleInterfaceController controls the display of quotes on the GUI
	 * The display of quote also changes at intervals
	 * It uses sub-classes to retrieve the list of quotes from a quote storage maintained in UI
	 * 
	 */
	
	private static final int CHANGE_QUOTE_INTERVAL = 120000;
	
	@FXML
	private Text quote;
	private Timer animate = new Timer(true);
	
	/**
	 * Constructor method
	 * @param mainController The primary controller linking this and the other controllers
	 */
	public void init(MainGUIController mainController) {
		animateQuote();
	}

	private void animateQuote() {
		animate.schedule(new TimerTask() {
			@Override
			public void run() {   	
				quote.setText(QuoteGenerator.generateRandomQuote());

				FadeTransition ft = new FadeTransition(Duration.millis(800), quote);
				ft.setFromValue(0);
				ft.setToValue(1);
				ft.play();
			}
		}, 0, CHANGE_QUOTE_INTERVAL);
	}
}
```
###### \ui\Controllers\TitleQuotes\QuoteGenerator.java
``` java
package ui.Controllers.TitleQuotes;

import ui.Controllers.TitleQuotes.QuoteStorage;
import java.util.Date;

public class QuoteGenerator {
	
	/**
	 * This class retrieves quotes from the storage maintain by the UI
	 * It also generates a random number to which it will be send to the storage to generate
	 * the quote with that index
	 * 
	 */
    
    private static final int NUM_QUOTES = 21;
    
    /**
     * Gets a quote from storage
     * @return String This is the quote from QuoteStorage
     */
    public static String generateRandomQuote() {
        return QuoteStorage.parseQuoteList(randomGeneratorByDate());
    }

    private static int randomGeneratorByDate() {
        Date date = new Date();
        return (int) Math.abs(date.getTime() % NUM_QUOTES);
    }
}
```
###### \ui\Controllers\TitleQuotes\QuoteStorage.java
``` java
package ui.Controllers.TitleQuotes;

import java.util.ArrayList;

public class QuoteStorage {
	
	/**
	 * This class stores all the quotes
	 * It generates the quote list but does not display any of them
	 * It returns a quote depending on the number it receive
	 * 
	 */

	private static final String QUOTE_ONE = 
			"Hard work beats talent when talent fails to work hard? "
					+ "-- Kevin Durant";
	private static final String QUOTE_TWO = 
			"Strive not to be a success, but rather be a value? "
					+ "-- Albert Einstein";
	private static final String QUOTE_THREE = 
			"The secret of success is to do the common things uncommonly well? "
					+ "-- John D. Rockefeller";
	private static final String QUOTE_FOUR = 
			"Two roads diverged in a wood, and I took the one less traveled by, and that has made all the difference? "
					+ "-- Robert Frost";
	private static final String QUOTE_FIVE = 
			"Should Plan A fails, remember, you have 25 letters left? "
					+ "-- Anonymous";
	private static final String QUOTE_SIX = 
			"I won't run away anymore... I won't go back on my word... that is my ninja way!? "
					+ "-- Uzumaki Naruto";
	private static final String QUOTE_SEVEN = 
			"Keep your eyes on the stars, and your feet on the ground? "
					+ "-- Theodore Roosevelt";
	private static final String QUOTE_EIGHT = 
			"Your time is limited, so dont waste it living someone elses life? "
					+ "-- Steve Jobs";
	private static final String QUOTE_NINE = 
			"People often say that motivation doesnt last. Well, neither does bathing. Thats why we recommend it daily? "
					+ "-- Zig Ziglar";
	private static final String QUOTE_TEN = 
			"You can never cross the ocean until you have the courage to lose sight of the shore? "
					+ "-- Christopher Columbus";
	private static final String QUOTE_ELEVEN = 
			"Remember no one can make you feel inferior without your consent? "
					+ "-- Eleanor Roosevelt";
	private static final String QUOTE_TWELVE = 
			"Always do your best. What you plant now, you will harvest later? "
					+ "-- Og Mandino";
	private static final String QUOTE_THIRTEEN = 
			"Just do it? "
					+ "-- Nike";
	private static final String QUOTE_FOURTEEN = 
			"If you think you are too small to be effective, you have never been in the dark with a mosquito? "
					+ "-- Betty Reese";
	private static final String QUOTE_FIFTEEN = 
			"Age is of no importance unless youre a cheese? "
					+ "-- Billy Burke";
	private static final String QUOTE_SIXTEEN = 
			"Always borrow money from a pessimist. He wont expect it back? "
					+ "-- Oscar Wilde";
	private static final String QUOTE_SEVENTEEN = 
			"Every walk starts with a step? "
					+ "-- Anonymous";
	private static final String QUOTE_EIGHTEEN = 
			"In my body, where the shame gland should be, there is a second awesome gland. True story? "
					+ "-- Barney Stinson";
	private static final String QUOTE_NINETEEN = 
			"Believe you can and you're halfway there? "
					+ "-- Theodore Roosevelt";
	private static final String QUOTE_TWENTY = 
			"Your most unhappy customers are your greatest source of learning? "
					+ "-- Bill Gates";
	private static final String QUOTE_TWENTYONE = 
			"Innovation distinguishes between a leader and a follower? "
					+ "-- Steve Jobs";

	private static ArrayList<String> quoteList = new ArrayList<String>();

	/**
	 * Generates the entire quote list and retrieves a quote depending of the number received
	 * @param quoteNumber This is a random number from QuoteGenerator
	 * @return String This is the quote
	 */
	public static String parseQuoteList(int quoteNumber) {
		initQuoteList();
		return quoteList.get(quoteNumber);
	}

	private static void initQuoteList() {
		quoteList.add(QUOTE_ONE);
		quoteList.add(QUOTE_TWO);
		quoteList.add(QUOTE_THREE);
		quoteList.add(QUOTE_FOUR);
		quoteList.add(QUOTE_FIVE);
		quoteList.add(QUOTE_SIX);
		quoteList.add(QUOTE_SEVEN);
		quoteList.add(QUOTE_EIGHT);
		quoteList.add(QUOTE_NINE);
		quoteList.add(QUOTE_TEN);
		quoteList.add(QUOTE_ELEVEN);
		quoteList.add(QUOTE_TWELVE);
		quoteList.add(QUOTE_THIRTEEN);
		quoteList.add(QUOTE_FOURTEEN);
		quoteList.add(QUOTE_FIFTEEN);
		quoteList.add(QUOTE_SIXTEEN);
		quoteList.add(QUOTE_SEVENTEEN);
		quoteList.add(QUOTE_EIGHTEEN);
		quoteList.add(QUOTE_NINETEEN);
		quoteList.add(QUOTE_TWENTY);
		quoteList.add(QUOTE_TWENTYONE);
	}
}
```
###### \ui\Controllers\TutorialRenderer.java
``` java
package ui.Controllers;

import java.io.IOException;

import org.controlsfx.control.PopOver;
import org.controlsfx.control.PopOver.ArrowLocation;

import javafx.event.EventHandler;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.util.Duration;

public class TutorialRenderer {

	/**
	 * This class renders the tutorial mode via several FXML files
	 * It also detects key event that occurs in tutorial mode
	 * It also set/adjust the properties of the tutorial display
	 * 
	 */

	private static final int LIST_OFFSET_Y = 125;
	private static final int LIST_OFFSET_X = 0;
	private static final int CL_OFFSET_X = 540;

	private static final int TUTORIAL_ANIMATION_DURATION = 300;

	private static final String TUTORIAL_1_PATH = "/ui/View/Tutorial1.fxml";
	private static final String TUTORIAL_2_PATH = "/ui/View/Tutorial2.fxml";
	private static final String TUTORIAL_3_PATH = "/ui/View/Tutorial3.fxml";
	private static final String TUTORIAL_4_PATH = "/ui/View/Tutorial4.fxml";
	private static final String TUTORIAL_5_PATH = "/ui/View/Tutorial5.fxml";

	private static final int INTERFACE_TUTORIAL = 1;
	private static final int COMMAND_TUTORIAL = 2;
	private static final int READ_LIST_TUTORIAL = 3;
	private static final int HELP_TUTORIAL = 4;

	private PopOver commandLineTutorial;
	private PopOver listTutorial;
	private PopOver commandAddTutorial; 
	private PopOver readListTutorial;
	private PopOver helpTutorial;

	private MainGUIController main;

	public boolean tutorialFlag = false;
	private double coordinateX = 0;
	private double coordinateY = 0;
	private int currentTutorial = INTERFACE_TUTORIAL;

	/**
	 * Constructor method
	 * @param mainController The primary controller linking this and the other controllers
	 */
	public TutorialRenderer(MainGUIController mainController) {
		main = mainController;
		initPopOver();
	}

	private void initPopOver() {
		commandLineTutorial = new PopOver();
		listTutorial = new PopOver();
		commandAddTutorial = new PopOver();
		readListTutorial = new PopOver();
		helpTutorial = new PopOver();
	}

	/**
	 * Loads tutorial into view
	 * @throws IOException If there is an I/O error
	 */
	public void loadTutorial() {
		initPopOver();
		setBoundsForCurrentTutorial();
		try {
			checkCurrentTutorialPageAndLoadNextTutorial();
		} catch(IOException e) {
			e.printStackTrace();
		}
	}

	private void checkCurrentTutorialPageAndLoadNextTutorial() throws IOException {
		if(currentTutorial == INTERFACE_TUTORIAL) {
			openCommandLineTutorial();
			openListTutorial();
			tutorialKeyHandler(listTutorial);

		} else if(currentTutorial == COMMAND_TUTORIAL) {
			openCommandAddTutorial();
			tutorialKeyHandler(commandAddTutorial);

		} else if(currentTutorial == READ_LIST_TUTORIAL) {
			openReadListTutorial();
			tutorialKeyHandler(readListTutorial);

		} else if(currentTutorial == HELP_TUTORIAL) {
			openHelpTutorial();
			tutorialKeyHandler(helpTutorial);
		}
	}

	private void openHelpTutorial() throws IOException {
		helpTutorial.setContentNode(FXMLLoader.load(getClass().getResource(TUTORIAL_5_PATH)));
		getCoordinates(helpTutorial, main.getCommandLine());
		setPopOverProperties(helpTutorial);
		helpTutorial.setArrowLocation(ArrowLocation.BOTTOM_CENTER);
		helpTutorial.show(main.getCommandLine(), coordinateX+CL_OFFSET_X, coordinateY, Duration.millis(TUTORIAL_ANIMATION_DURATION));
	}

	private void openReadListTutorial() throws IOException {
		readListTutorial.setContentNode(FXMLLoader.load(getClass().getResource(TUTORIAL_4_PATH)));
		getCoordinates(readListTutorial, main.getList());
		setPopOverProperties(readListTutorial);
		readListTutorial.setArrowLocation(ArrowLocation.TOP_CENTER);
		readListTutorial.show(main.getList(), coordinateX+LIST_OFFSET_X, coordinateY+LIST_OFFSET_Y, Duration.millis(TUTORIAL_ANIMATION_DURATION));
	}

	private void openCommandAddTutorial() throws IOException {
		commandAddTutorial.setContentNode(FXMLLoader.load(getClass().getResource(TUTORIAL_3_PATH)));
		getCoordinates(commandAddTutorial, main.getCommandLine());
		setPopOverProperties(commandAddTutorial);
		commandAddTutorial.setArrowLocation(ArrowLocation.BOTTOM_CENTER);
		commandAddTutorial.show(main.getCommandLine(), coordinateX+CL_OFFSET_X, coordinateY, Duration.millis(TUTORIAL_ANIMATION_DURATION));
	}

	private void openListTutorial() throws IOException {
		listTutorial.setContentNode(FXMLLoader.load(getClass().getResource(TUTORIAL_2_PATH)));
		getCoordinates(listTutorial, main.getList());
		setPopOverProperties(listTutorial);
		listTutorial.setArrowLocation(ArrowLocation.TOP_CENTER);
		listTutorial.show(main.getList(), coordinateX+LIST_OFFSET_X, coordinateY+LIST_OFFSET_Y, Duration.millis(TUTORIAL_ANIMATION_DURATION));
	}

	private void openCommandLineTutorial() throws IOException {
		commandLineTutorial.setContentNode(FXMLLoader.load(getClass().getResource(TUTORIAL_1_PATH)));
		getCoordinates(commandLineTutorial, main.getCommandLine());
		setPopOverProperties(commandLineTutorial);
		commandLineTutorial.setArrowLocation(ArrowLocation.BOTTOM_CENTER);
		commandLineTutorial.show(main.getCommandLine(), coordinateX+CL_OFFSET_X, coordinateY, Duration.millis(TUTORIAL_ANIMATION_DURATION));
	}

	private void setBoundsForCurrentTutorial() {
		if(currentTutorial > HELP_TUTORIAL) {
			currentTutorial = HELP_TUTORIAL;
		} else if(currentTutorial < INTERFACE_TUTORIAL) {
			currentTutorial = INTERFACE_TUTORIAL;
		}
	}

	private void hideAll() {
		commandLineTutorial.hide(Duration.ONE);
		listTutorial.hide(Duration.ONE);
		commandAddTutorial.hide(Duration.ONE);
		readListTutorial.hide(Duration.ONE);
		helpTutorial.hide(Duration.ONE);
	}


	private void getCoordinates(PopOver target, Node targetContent) {
		Scene scene = targetContent.getScene();
		Point2D windowCoord = new Point2D(scene.getWindow().getX(), scene.getWindow().getY());
		Point2D sceneCoord = new Point2D(scene.getX(), scene.getY());
		Point2D nodeCoord = targetContent.localToScene(0.0, 0.0);
		getCoordinateX(windowCoord, sceneCoord, nodeCoord);
		getCoordinateY(windowCoord, sceneCoord, nodeCoord);
	}

	private void getCoordinateY(Point2D windowCoord, Point2D sceneCoord, Point2D nodeCoord) {
		coordinateY = Math.round(windowCoord.getY() + sceneCoord.getY() + nodeCoord.getY());
	}

	private void getCoordinateX(Point2D windowCoord, Point2D sceneCoord, Point2D nodeCoord) {
		coordinateX = Math.round(windowCoord.getX() + sceneCoord.getX() + nodeCoord.getX());
	}

	private void setPopOverProperties(PopOver popOver) {
		popOver.setAutoFix(false);
		popOver.setAutoHide(false);
	}

	/**
	 * Detects key events that occurs in tutorial mode (e.g. next, previous tutorial)
	 * @param node This node is the tutorial display node
	 */
	private void tutorialKeyHandler(PopOver node) {
		node.addEventHandler(KeyEvent.KEY_PRESSED, new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent event) {
				if(event.getCode() == KeyCode.RIGHT || event.getCode() == KeyCode.ENTER) {
					proceedToNextTutorial(event);
				} else if (event.getCode() == KeyCode.LEFT) {
					revertToPreviousTutorial(event);
				} else if (event.getCode() == KeyCode.ESCAPE) {
					tutorialFlag = false;
				} else if (event.getCode() == KeyCode.F12) {
					tutorialFlag = false;
				}
			}
		});
	}

	private void proceedToNextTutorial(KeyEvent event) {
		currentTutorial++;
		if(currentTutorial == INTERFACE_TUTORIAL+1 ||
				currentTutorial == READ_LIST_TUTORIAL+1) {
			event.consume();
		}
		hideAll();
		loadTutorial();

	}

	private void revertToPreviousTutorial(KeyEvent event) {
		currentTutorial--;
		event.consume();
		hideAll();
		loadTutorial();
	}

}
```
###### \ui\View\CommandLineInterface.fxml
``` fxml

<?import java.lang.*?>
<?import java.util.*?>
<?import java.net.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.*?>

<VBox alignment="CENTER" prefHeight="50.0" prefWidth="500.0"
	BorderPane.alignment="CENTER" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="ui.Controllers.CommandLineController" spacing="10">
	<children>
		<Pane />
		<TextField fx:id="userInput" alignment="CENTER" promptText="Enter your command here"
			onKeyPressed="#handleSubmitButtonAction" prefHeight="35.0" prefWidth="800.0">
		</TextField>
		<Text fx:id="feedbackHelp" strokeType="OUTSIDE" strokeWidth="0.0"
			textAlignment="CENTER" wrappingWidth="600" />
		<Text fx:id="feedbackMain" strokeType="OUTSIDE" strokeWidth="0.0"
			textAlignment="CENTER" wrappingWidth="600" />
	</children>
	<BorderPane.margin>
		<Insets left="50.0" right="50.0" />
	</BorderPane.margin>
</VBox>
```
###### \ui\View\HelpPage.fxml
``` fxml

<?import java.lang.*?>
<?import java.util.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.*?>
<?import javafx.scene.text.*?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.layout.HBox?>

<AnchorPane prefHeight="400.0" prefWidth="600.0"
	xmlns:fx="http://javafx.com/fxml/1" fx:controller="ui.Controllers.HelpPageController">
	<children>
		<StackPane layoutX="15.0" layoutY="10.0" prefHeight="390.0"
			prefWidth="585.0" AnchorPane.bottomAnchor="0" AnchorPane.leftAnchor="30"
			AnchorPane.rightAnchor="30" AnchorPane.topAnchor="-50" fx:id="helpListContainer">
			<children>
				<VBox>
					<children>
						<HBox spacing="20">
							<children>
								<Pane HBox.hgrow="ALWAYS" />
								<ImageView layoutX="29.0" layoutY="44.0" fitHeight="40.0"
									fitWidth="40.0" pickOnBounds="true" preserveRatio="true">
									<image>
										<Image url="@../Application/Stylesheets/Background/info-icon.png" />
									</image>
								</ImageView>
								<Text fx:id="helpHeading" text="Need help?" />
								<Pane HBox.hgrow="ALWAYS" />
							</children>
						</HBox>
						<TableView fx:id="helpList" prefHeight="380.0"
							prefWidth="600.0" />
					</children>
				</VBox>
			</children>
		</StackPane>
	</children>

	<stylesheets>
		<URL value="@../Application/Stylesheets/HelpPage.css" />
	</stylesheets>
</AnchorPane>
```
###### \ui\View\ListInterface.fxml
``` fxml

<?import java.lang.*?>
<?import java.util.*?>
<?import javafx.scene.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>

<HBox prefHeight="700.0" prefWidth="800.0" alignment="CENTER"
	xmlns:fx="http://javafx.com/fxml/1" fx:id="todoListContainer"
	fx:controller="ui.Controllers.ListInterfaceController">
	<children>
		<TabPane fx:id="tabPane" prefWidth="800.0" prefHeight="700.0">
			<tabs>
				<Tab fx:id="tabPending">
					<ListView fx:id="todoList" HBox.hgrow="ALWAYS" prefHeight="500.0"
						prefWidth="800.0" />
				</Tab>
			</tabs>
		</TabPane>
	</children>
</HBox>
```
###### \ui\View\MainGUI.fxml
``` fxml

<?import java.lang.*?>
<?import java.util.*?>
<?import java.net.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.text.*?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.StackPane?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity"
	minHeight="-Infinity" minWidth="-Infinity" prefHeight="640.0"
	prefWidth="768.0" styleClass="root" fx:id="backgroundPane"
	xmlns:fx="http://javafx.com/fxml/1" fx:controller="ui.Controllers.MainGUIController">
	<padding>
		<Insets bottom="25.0" left="25.0" right="25.0" top="25.0" />
	</padding>

	<children>
		<BorderPane prefHeight="640.0" prefWidth="768.0"
			styleClass="borderPane" AnchorPane.bottomAnchor="0.0"
			AnchorPane.leftAnchor="10.0" AnchorPane.rightAnchor="10.0"
			AnchorPane.topAnchor="0.0">

			<!-- Title -->
			<top>
				<fx:include fx:id="title" source="/ui/View/TitleInterface.fxml" />
			</top>

			<!-- Command Line -->
			<bottom>
				<fx:include fx:id="commandLine" source="/ui/View/CommandLineInterface.fxml" />
			</bottom>

			<!-- to do list -->
			<center>
				<VBox>
					<fx:include fx:id="supportFeatures" source="/ui/View/SupportFeaturesInterface.fxml" />
					<fx:include fx:id="todoList" source="/ui/View/ListInterface.fxml" />
				</VBox>
			</center>

		</BorderPane>
	</children>


</AnchorPane>
```
###### \ui\View\SupportFeaturesInterface.fxml
``` fxml

<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.text.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.*?>

<VBox fx:id="mainPane" prefHeight="800.0" prefWidth="200.0"
	spacing="20" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ui.Controllers.SupportFeaturesController">
	<children>
		<ImageView fx:id="imageView" layoutX="29.0" layoutY="44.0"
			fitHeight="150.0" fitWidth="150.0" pickOnBounds="true" preserveRatio="true">
			<image>
				<Image url="@../Application/Stylesheets/Background/catalist_icon.png" />
			</image>
		</ImageView>
		<Text fx:id="titleMessage" text="Welcome to CataList!" />
		<Text fx:id="subMessage" text="Type 'help' for more information" />
	</children>
</VBox>

```
###### \ui\View\TitleInterface.fxml
``` fxml

<?import java.lang.*?>
<?import java.util.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.text.*?>

<HBox prefHeight="70.0" prefWidth="200.0" BorderPane.alignment="CENTER" 
      xmlns:fx="http://javafx.com/fxml/1" alignment="CENTER" 
      fx:controller="ui.Controllers.TitleInterfaceController" >
    <Text fx:id="quote" 
          strokeType="OUTSIDE" strokeWidth="0.0" 
          textAlignment="CENTER" wrappingWidth="700"/>
</HBox>
```
###### \ui\View\Tutorial1.fxml
``` fxml


<?import java.lang.*?>
<?import java.util.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.*?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.*?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>

<AnchorPane prefHeight="300" prefWidth="300"
	xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<StackPane AnchorPane.bottomAnchor="20"
			AnchorPane.leftAnchor="20" AnchorPane.rightAnchor="20"
			AnchorPane.topAnchor="20">
			<children>
				<VBox spacing="10" fx:id="tutorialContainer">
					<children>
						<Text fx:id="tutorialMessage"
							text="This is the command line. Type here 
					&#10;to tell the application what to do." />
						<ImageView layoutX="40.0" layoutY="44.0" fitHeight="200.0"
							fitWidth="300.0" pickOnBounds="true" preserveRatio="true">
							<image>
								<Image url="@../Application/Stylesheets/Background/input.png" />
							</image>
						</ImageView>
						<Text fx:id="tutorialMessage"
							text="The feedback for each input is shown
					&#10;below the command line." />
						<ImageView layoutX="40.0" layoutY="44.0" fitHeight="200.0"
							fitWidth="300.0" pickOnBounds="true" preserveRatio="true">
							<image>
								<Image url="@../Application/Stylesheets/Background/cli.png" />
							</image>
						</ImageView>
						<Text fx:id="exitMessage" text="Press RIGHT to move on." />
						<Text fx:id="exitMessage" text="Press ESC to quit." />
					</children>
				</VBox>
			</children>
		</StackPane>
	</children>
</AnchorPane>

```
###### \ui\View\Tutorial2.fxml
``` fxml

<?import java.lang.*?>
<?import java.util.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.*?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.*?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>

<AnchorPane prefHeight="300" prefWidth="300"
	xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<StackPane AnchorPane.bottomAnchor="20"
			AnchorPane.leftAnchor="20" AnchorPane.rightAnchor="20"
			AnchorPane.topAnchor="20">
			<children>
				<VBox spacing="10" fx:id="tutorialContainer">
					<children>
						<Text fx:id="tutorialMessage"
							text="This is the to-do list.
					&#10;Your pending tasks will be displayed here.
					&#10;The task details is on the left of the list." />
						<ImageView layoutX="40.0" layoutY="44.0" fitHeight="40.0"
							fitWidth="280.0" pickOnBounds="true" preserveRatio="false">
							<image>
								<Image url="@../Application/Stylesheets/Background/task_details.png" />
							</image>
						</ImageView>
						<Text fx:id="tutorialMessage"
							text="The task deadline is on the right of the list." />
						<ImageView layoutX="40.0" layoutY="44.0" fitHeight="40.0"
							fitWidth="280.0" pickOnBounds="true" preserveRatio="false">
							<image>
								<Image url="@../Application/Stylesheets/Background/task_time.png" />
							</image>
						</ImageView>
						<Text fx:id="exitMessage" text="Press RIGHT to move on" />
						<Text fx:id="exitMessage" text="Press ESC to quit" />
					</children>
				</VBox>
			</children>
		</StackPane>
	</children>
</AnchorPane>

```
###### \ui\View\Tutorial3.fxml
``` fxml


<?import java.lang.*?>
<?import java.util.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.*?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.*?>

<AnchorPane prefHeight="100" prefWidth="200" 
xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<StackPane AnchorPane.bottomAnchor="20" AnchorPane.leftAnchor="20"
			AnchorPane.rightAnchor="20" AnchorPane.topAnchor="20">
			<children>
				<VBox spacing="10" fx:id="tutorialContainer">
					<children>
					<Text fx:id="tutorialMessage"
							text="Let's try it out! Type in the 
					&#10;following input or another
					&#10;input of the similar format:" />
					<Text fx:id="tutorialSamples"
							text="add work 8am 1/4/16" />
					<Text fx:id="tutorialMessage"
							text="You may choose to omit
					&#10;the words after 'work'. 
					&#10;Once you are done, press ENTER!" />
						<Text fx:id="exitMessage" text="Press LEFT to go back a step." />
						<Text fx:id="exitMessage" text="Press RIGHT to move on" />
						<Text fx:id="exitMessage" text="Press ESC to quit." />
					</children>
				</VBox>
			</children>
		</StackPane>
	</children>
</AnchorPane>

```
###### \ui\View\Tutorial4.fxml
``` fxml

<?import java.lang.*?>
<?import java.util.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.*?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.*?>

<AnchorPane prefHeight="200" prefWidth="200" 
xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<StackPane AnchorPane.bottomAnchor="20" AnchorPane.leftAnchor="20"
			AnchorPane.rightAnchor="20" AnchorPane.topAnchor="20">
			<children>
				<VBox spacing="10" fx:id="tutorialContainer">
					<children>
					<Text fx:id="tutorialMessage"
							text="Here, your task has been added!
					&#10;The sequence of the time and date
					&#10;is interchangeable. Now you can
					&#10;start creating your own tasks!" />
						<Text fx:id="exitMessage" text="Press LEFT to go back a step." />
						<Text fx:id="exitMessage" text="Press RIGHT to move on." />
						<Text fx:id="exitMessage" text="Press ESC to quit." />
					</children>
				</VBox>
			</children>
		</StackPane>
	</children>
</AnchorPane>
```
###### \ui\View\Tutorial5.fxml
``` fxml

<?import java.lang.*?>
<?import java.util.*?>
<?import javafx.scene.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.*?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.*?>

<AnchorPane prefHeight="200" prefWidth="200" 
xmlns:fx="http://javafx.com/fxml/1">
	<children>
		<StackPane AnchorPane.bottomAnchor="20" AnchorPane.leftAnchor="20"
			AnchorPane.rightAnchor="20" AnchorPane.topAnchor="20">
			<children>
				<VBox spacing="10" fx:id="tutorialContainer">
					<children>
					<Text fx:id="tutorialMessage"
							text="You may also try other
					&#10;commands such as:" />
					<Text fx:id="tutorialSamples"
							text="delete 1
							&#10;edit 1 6pm" />
					<Text fx:id="tutorialMessage"
							text="Type 'help' for more info
					&#10;or you can scroll between
					&#10;tutorials with the 
					&#10;LEFT and RIGHT keys." />
						<Text fx:id="exitMessage" text="Press LEFT to go back a step." />
						<Text fx:id="exitMessage" text="Press ESC to quit." />
					</children>
				</VBox>
			</children>
		</StackPane>
	</children>
</AnchorPane>
```
